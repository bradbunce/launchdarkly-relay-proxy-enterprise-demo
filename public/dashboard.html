<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LaunchDarkly Relay Proxy - Unified Dashboard</title>
  <!-- LaunchDarkly Client-Side ID - Injected from environment variable -->
  <meta name="ld-client-id" content="${LAUNCHDARKLY_CLIENT_SIDE_ID}">
  <!-- LaunchDarkly JavaScript SDK v3.9.0 (local) -->
  <script src="/vendor/ldclient.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background-color: #f5f5f5;
      overflow: hidden;
    }

    .dashboard-container {
      width: 2056px;
      height: 1285px;
      display: grid;
      grid-template-rows: 771px 514px;
      grid-template-columns: 1fr;
      gap: 0;
      overflow: hidden;
      transition: grid-template-rows 0.3s ease;
    }
    
    .dashboard-container.hide-logs {
      grid-template-rows: 1fr 0px;
    }

    .services-section {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap: 20px;
      padding: 20px;
      background-color: #f5f5f5;
      height: 100%;
      overflow: hidden;
    }
    
    /* Panel 1 container holds both Node.js and Python panels */
    #panel-1-container {
      position: relative;
    }
    
    /* Hide panels by default, show based on flag */
    #node-service-panel,
    #python-service-panel {
      display: none;
    }
    
    #node-service-panel.active,
    #python-service-panel.active {
      display: flex;
    }

    .logs-section {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
      padding: 10px;
      background-color: #0a0a0a;
      transition: opacity 0.3s ease;
    }
    
    .logs-section.hidden {
      display: none;
    }
    
    /* Increase data store window heights when terminal panels are hidden */
    .dashboard-container.hide-logs #node-sdk-cache {
      max-height: 794px !important; /* 280px + 514px */
    }
    
    .dashboard-container.hide-logs #php-sdk-cache {
      max-height: 794px !important; /* 280px + 514px */
    }
    
    .dashboard-container.hide-logs #python-sdk-cache {
      max-height: 794px !important; /* 280px + 514px */
    }
    
    .dashboard-container.hide-logs #relay-proxy-cache {
      max-height: 794px !important; /* 400px + 394px - expanded to match others */
    }
    
    .dashboard-container.hide-logs #redis-data-store {
      max-height: 794px !important; /* 517px + 277px - expanded to match others */
    }

    .service-panel {
      background-color: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      position: relative;
      z-index: 10;
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    
    .sdk-cache-display {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
    }
    
    .sdk-cache-display > div:last-child {
      flex: 1;
      min-height: 0;
    }

    .service-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }

    .service-header h2 {
      font-size: 24px;
      color: #333;
    }
    
    .service-header-left {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .service-logo {
      height: 32px;
      width: auto;
      object-fit: contain;
    }
    
    .service-header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .control-icon-button {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: normal;
      line-height: 28px;
      transition: all 0.2s ease;
      padding: 0;
      margin: 0;
      font-family: Arial, sans-serif;
    }
    
    .control-icon-button:hover {
      transform: scale(1.3);
    }
    
    .control-icon-button:active {
      transform: scale(0.9);
    }
    
    .control-icon-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }
    
    .control-icon-button.start {
      color: #4caf50;
      font-size: 20px;
    }
    
    .control-icon-button.stop {
      color: #f44336;
    }
    
    .control-icon-button.restart {
      color: #ff9800;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      background-color: #f5f5f5;
      border-radius: 12px;
      border: 1px solid #e0e0e0;
    }

    .status-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      transition: opacity 0.3s ease;
    }

    .status-dot.red {
      background-color: #f44336;
    }

    .status-dot.orange {
      background-color: #ff9800;
    }

    .status-dot.green {
      background-color: #4caf50;
    }

    .status-dot.dimmed {
      opacity: 0.2;
    }

    .flag-display {
      margin-bottom: 20px;
    }

    .flag-display label {
      font-size: 14px;
      color: #666;
      display: block;
      margin-bottom: 8px;
    }

    .flag-value {
      font-size: 18px;
      font-weight: bold;
      color: #405BFF;
      padding: 12px;
      background-color: #f0f2ff;
      border-radius: 4px;
    }

    .sdk-config {
      font-size: 14px;
      color: #666;
      margin-bottom: 20px;
    }

    .context-display {
      margin-top: 20px;
    }

    .context-display h4 {
      font-size: 14px;
      color: #333;
      margin-bottom: 10px;
    }

    .context-display button {
      background-color: #405BFF;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 10px;
    }

    .context-display button:hover {
      background-color: #3347cc;
    }

    .log-console {
      background-color: #1e1e1e;
      border-radius: 4px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .log-console-header {
      background-color: #2d2d2d;
      padding: 8px 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .log-console-header h3 {
      font-size: 12px;
      color: #fff;
      font-weight: 600;
    }

    .log-console-header button {
      background-color: transparent;
      color: #999;
      border: 1px solid #444;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
    }

    .log-console-header button:hover {
      background-color: #3d3d3d;
      color: #fff;
    }

    .log-console-output {
      flex: 1;
      padding: 10px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 12px;
      color: #d4d4d4;
      overflow-y: auto;
      line-height: 1.5;
    }

    .log-line {
      margin-bottom: 2px;
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
    }

    .modal.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
    }

    .modal-content {
      position: relative;
      background-color: white;
      border-radius: 8px;
      padding: 30px;
      width: 500px;
      max-width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      z-index: 1001;
    }
    
    /* Wider modal for relay status */
    #relay-status-modal .modal-content {
      width: 800px;
      max-width: 95%;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    
    #relay-status-modal .modal-body {
      overflow-y: auto;
      flex: 1;
    }

    .modal-header {
      margin-bottom: 20px;
    }

    .modal-header h3 {
      font-size: 20px;
      color: #333;
      margin: 0;
    }

    .modal-body {
      margin-bottom: 20px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    .form-group label {
      display: block;
      font-size: 14px;
      color: #333;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .radio-group {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }

    .radio-option {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .radio-option input[type="radio"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    .radio-option label {
      font-size: 14px;
      color: #333;
      cursor: pointer;
      margin: 0;
      font-weight: normal;
    }

    .form-group input[type="text"],
    .form-group input[type="email"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      font-family: inherit;
    }

    .form-group input[type="text"]:focus,
    .form-group input[type="email"]:focus {
      outline: none;
      border-color: #405BFF;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .modal-footer button {
      padding: 10px 20px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
    }

    .btn-primary {
      background-color: #405BFF;
      color: white;
    }

    .btn-primary:hover {
      background-color: #3347cc;
    }

    .btn-secondary {
      background-color: #f5f5f5;
      color: #333;
      border: 1px solid #ddd;
    }

    .btn-secondary:hover {
      background-color: #e8e8e8;
    }

    /* Connection Control Styles */
    .connection-control {
      margin-top: 20px;
      padding: 15px;
      background: #f5f5f5;
      border-radius: 8px;
    }

    .connection-toggle {
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
    }

    .connection-label {
      font-weight: 600;
      color: #333;
    }

    .toggle-switch {
      position: relative;
      width: 50px;
      height: 24px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    input:checked + .toggle-slider {
      background-color: #4CAF50;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }

    input:disabled + .toggle-slider {
      background-color: #ddd;
      cursor: not-allowed;
    }

    .status-text {
      font-weight: 500;
      padding: 4px 12px;
      border-radius: 4px;
    }

    .status-text.connected {
      color: #2e7d32;
      background: #e8f5e9;
    }

    .status-text.disconnected {
      color: #d32f2f;
      background: #ffebee;
    }

    .status-text.stopped {
      color: #757575;
      background: #f5f5f5;
    }

    .error-message {
      margin-top: 10px;
      padding: 10px;
      background: #ffebee;
      color: #c62828;
      border-radius: 4px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="dashboard-container">
    <!-- Services Section (Top 60%) -->
    <div class="services-section">
      <!-- Panel 1 Container (Node.js OR Python based on flag) -->
      <div id="panel-1-container">
        <!-- Node.js Service Panel -->
        <div class="service-panel active" id="node-service-panel">
        <div class="service-header">
          <div class="service-header-left">
            <img src="Node.js_logo.svg.png" alt="Node.js" class="service-logo" />
            <h2>Node.js Service</h2>
          </div>
          <div class="service-header-right">
            <button id="node-start-button" class="control-icon-button start" title="Start Node.js Service">â–¶</button>
            <button id="node-stop-button" class="control-icon-button stop" title="Stop Node.js Service">â– </button>
            <button id="node-restart-button" class="control-icon-button restart" title="Restart Node.js Service">â†»</button>
            <div class="status-indicator" id="node-status">
              <span class="status-dot red dimmed" id="node-status-red"></span>
              <span class="status-dot orange dimmed" id="node-status-orange"></span>
              <span class="status-dot green dimmed" id="node-status-green"></span>
            </div>
          </div>
        </div>
        
        <div class="sdk-config">
          <strong>SDK Client Mode:</strong> <span id="node-sdk-mode">Proxy Mode</span>
        </div>
        
        <div class="flag-display">
          <label>Feature Flag: user-message</label>
          <div class="flag-value" id="node-flag-value">Loading...</div>
        </div>
        
        <div class="context-display">
          <h4>Current Context</h4>
          <div id="node-context-info" style="font-size: 13px; line-height: 1.6; color: #555;">
            <div><strong>Type:</strong> <span id="node-context-type">Anonymous</span></div>
            <div><strong>Key:</strong> <span id="node-context-key" style="font-family: monospace; font-size: 11px;">Loading...</span></div>
            <div id="node-context-attributes" style="margin-top: 5px; padding-top: 5px; border-top: 1px solid #eee;">
              <!-- Attributes will be populated here -->
            </div>
          </div>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="node-context-button">Change Context</button>
            <button id="node-test-evaluation" class="btn-secondary">Test Flag Evaluation</button>
          </div>
        </div>
        
        <div class="hash-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="font-size: 13px; color: #333; margin: 0; font-weight: 600;">ðŸ”¢ Bucketing Hash Values</h4>
            <a href="#" id="node-hash-toggle" style="font-size: 12px; color: #405BFF; text-decoration: none; cursor: pointer;">Show</a>
          </div>
          <div id="node-hash-content" style="display: none;">
            <div id="node-hash-info" style="font-size: 12px; line-height: 1.8; color: #555; font-family: 'Courier New', monospace; padding: 12px; background-color: #f8f9fa; border-radius: 4px; border-left: 3px solid #405BFF;">
              <div style="color: #999; font-style: italic;">Waiting for flag evaluation...</div>
            </div>
          </div>
        </div>
        
        <div class="sdk-cache-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <h4 style="font-size: 14px; color: #333; margin-bottom: 10px;">SDK Data Store</h4>
          <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
            Raw flag configurations cached by the SDK (context-independent)
          </div>
          <div id="node-sdk-cache" style="font-size: 12px; line-height: 1.6; color: #555; max-height: 280px; overflow-y: auto; background-color: #f8f9fa; padding: 10px; border-radius: 4px; transition: max-height 0.3s ease;">
            <div style="color: #999; font-style: italic;">Waiting for SDK to initialize...</div>
          </div>
        </div>
      </div>

      <!-- Python Service Panel (hidden by default, shown when flag is 'python') -->
      <div class="service-panel" id="python-service-panel">
        <div class="service-header">
          <div class="service-header-left">
            <img src="python-logo-generic.svg" alt="Python" class="service-logo" />
            <h2>Python Service</h2>
          </div>
          <div class="service-header-right">
            <button id="python-start-button" class="control-icon-button start" title="Start Python Service">â–¶</button>
            <button id="python-stop-button" class="control-icon-button stop" title="Stop Python Service">â– </button>
            <button id="python-restart-button" class="control-icon-button restart" title="Restart Python Service">â†»</button>
            <div class="status-indicator" id="python-status">
              <span class="status-dot red dimmed" id="python-status-red"></span>
              <span class="status-dot orange dimmed" id="python-status-orange"></span>
              <span class="status-dot green dimmed" id="python-status-green"></span>
            </div>
          </div>
        </div>
        
        <div class="sdk-config">
          <strong>SDK Client Mode:</strong> <span id="python-sdk-mode">Default (Direct Connection)</span>
        </div>
        
        <div class="flag-display">
          <label>Feature Flag: user-message</label>
          <div class="flag-value" id="python-flag-value">Loading...</div>
        </div>
        
        <div class="context-display">
          <h4>Current Context</h4>
          <div id="python-context-info" style="font-size: 13px; line-height: 1.6; color: #555;">
            <div><strong>Type:</strong> <span id="python-context-type">Anonymous</span></div>
            <div><strong>Key:</strong> <span id="python-context-key" style="font-family: monospace; font-size: 11px;">Loading...</span></div>
            <div id="python-context-attributes" style="margin-top: 5px; padding-top: 5px; border-top: 1px solid #eee;">
              <!-- Attributes will be populated here -->
            </div>
          </div>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="python-context-button">Change Context</button>
            <button id="python-test-evaluation" class="btn-secondary">Test Flag Evaluation</button>
          </div>
        </div>
        
        <div class="hash-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="font-size: 13px; color: #333; margin: 0; font-weight: 600;">ðŸ”¢ Bucketing Hash Values</h4>
            <a href="#" id="python-hash-toggle" style="font-size: 12px; color: #405BFF; text-decoration: none; cursor: pointer;">Show</a>
          </div>
          <div id="python-hash-content" style="display: none;">
            <div id="python-hash-info" style="font-size: 12px; line-height: 1.8; color: #555; font-family: 'Courier New', monospace; padding: 12px; background-color: #f8f9fa; border-radius: 4px; border-left: 3px solid #405BFF;">
              <div style="color: #999; font-style: italic;">Waiting for flag evaluation...</div>
            </div>
          </div>
        </div>
        
        <div class="sdk-cache-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <h4 style="font-size: 14px; color: #333; margin-bottom: 10px;">SDK Data Store</h4>
          <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
            Raw flag configurations cached by the SDK (context-independent)
          </div>
          <div id="python-sdk-cache" style="font-size: 12px; line-height: 1.6; color: #555; max-height: 280px; overflow-y: auto; background-color: #f8f9fa; padding: 10px; border-radius: 4px;">
            <div style="color: #999; font-style: italic;">Loading...</div>
          </div>
        </div>
      </div>
      </div> <!-- End panel-1-container -->

      <!-- PHP Service Panel -->
      <div class="service-panel" id="php-service-panel">
        <div class="service-header">
          <div class="service-header-left">
            <img src="new-php-logo.svg" alt="PHP" class="service-logo" />
            <h2>PHP Service</h2>
          </div>
          <div class="service-header-right">
            <button id="php-start-button" class="control-icon-button start" title="Start PHP Service">â–¶</button>
            <button id="php-stop-button" class="control-icon-button stop" title="Stop PHP Service">â– </button>
            <button id="php-restart-button" class="control-icon-button restart" title="Restart PHP Service">â†»</button>
            <div class="status-indicator" id="php-status">
              <span class="status-dot red dimmed" id="php-status-red"></span>
              <span class="status-dot orange dimmed" id="php-status-orange"></span>
              <span class="status-dot green dimmed" id="php-status-green"></span>
            </div>
          </div>
        </div>
        
        <div class="sdk-config">
          <strong>SDK Client Mode:</strong> <span id="php-sdk-mode">Daemon Mode</span>
        </div>
        
        <div class="flag-display">
          <label>Feature Flag: user-message</label>
          <div class="flag-value" id="php-flag-value">Loading...</div>
        </div>
        
        <div class="context-display">
          <h4>Current Context</h4>
          <div id="php-context-info" style="font-size: 13px; line-height: 1.6; color: #555;">
            <div><strong>Type:</strong> <span id="php-context-type">Anonymous</span></div>
            <div><strong>Key:</strong> <span id="php-context-key" style="font-family: monospace; font-size: 11px;">Loading...</span></div>
            <div id="php-context-attributes" style="margin-top: 5px; padding-top: 5px; border-top: 1px solid #eee;">
              <!-- Attributes will be populated here -->
            </div>
          </div>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="php-edit-context">Change Context</button>
            <button id="php-test-evaluation" class="btn-secondary">Test Flag Evaluation</button>
          </div>
        </div>
        
        <div class="hash-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="font-size: 13px; color: #333; margin: 0; font-weight: 600;">ðŸ”¢ Bucketing Hash Values</h4>
            <a href="#" id="php-hash-toggle" style="font-size: 12px; color: #405BFF; text-decoration: none; cursor: pointer;">Show</a>
          </div>
          <div id="php-hash-content" style="display: none;">
            <div id="php-hash-info" style="font-size: 12px; line-height: 1.8; color: #555; font-family: 'Courier New', monospace; padding: 12px; background-color: #f8f9fa; border-radius: 4px; border-left: 3px solid #405BFF;">
              <div style="color: #999; font-style: italic;">Waiting for flag evaluation...</div>
            </div>
          </div>
        </div>
        
        <div class="sdk-cache-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <h4 style="font-size: 14px; color: #333; margin-bottom: 10px;">Redis Data Store</h4>
          <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
            Raw flag configurations from Redis (context-independent)
          </div>
          <div id="php-sdk-cache" style="font-size: 12px; line-height: 1.6; color: #555; max-height: 280px; overflow-y: auto; background-color: #f8f9fa; padding: 10px; border-radius: 4px; transition: max-height 0.3s ease;">
            <div style="color: #999; font-style: italic;">Waiting for SDK to initialize...</div>
          </div>
        </div>
      </div>

      <!-- Relay Proxy Enterprise Panel -->
      <div class="service-panel" id="relay-proxy-panel">
        <div class="service-header">
          <div class="service-header-left">
            <img src="launchdarkly-logo.svg" alt="LaunchDarkly" class="service-logo" />
            <h2>Relay Proxy Enterprise</h2>
          </div>
          <div class="service-header-right">
            <button id="relay-proxy-start-button" class="control-icon-button start" title="Start Relay Proxy">â–¶</button>
            <button id="relay-proxy-stop-button" class="control-icon-button stop" title="Stop Relay Proxy">â– </button>
            <button id="relay-proxy-restart-button" class="control-icon-button restart" title="Restart Relay Proxy">â†»</button>
            <div class="status-indicator" id="relay-proxy-status">
              <span class="status-dot red dimmed" id="relay-proxy-status-red"></span>
              <span class="status-dot orange dimmed" id="relay-proxy-status-orange"></span>
              <span class="status-dot green dimmed" id="relay-proxy-status-green"></span>
            </div>
          </div>
        </div>
        
        <div style="margin-bottom: 20px;">
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            <strong>Status:</strong> <span id="relay-proxy-status-text">Checking...</span>
          </div>
          <div style="font-size: 14px; color: #666;">
            <strong>Mode:</strong> Enterprise Relay Proxy
          </div>
        </div>
        
        <div style="display: flex; flex-direction: column; gap: 10px;">
          <button id="relay-status-button" class="btn-secondary" style="width: 100%; padding: 12px 20px; border: 1px solid #ddd; border-radius: 4px; background-color: white; cursor: pointer; font-size: 14px; font-weight: 500;">
            ðŸ“Š View Detailed Status
          </button>
          
          <button id="load-test-button" class="btn-secondary" style="width: 100%; padding: 12px 20px; border: 1px solid #ddd; border-radius: 4px; background-color: white; cursor: pointer; font-size: 14px; font-weight: 500;">
            âš¡ Run Load Test
          </button>
        </div>
        
        <!-- Connection Control Section -->
        <div class="connection-control">
          <label class="connection-toggle">
            <span class="connection-label">Connection to LaunchDarkly:</span>
            <div class="toggle-switch">
              <input type="checkbox" id="relay-connection-toggle" checked>
              <span class="toggle-slider"></span>
            </div>
            <span id="connection-status-text" class="status-text connected">
              Connected
            </span>
          </label>
        </div>
        
        <div id="connection-error" class="error-message" style="display: none;"></div>
        
        <div class="sdk-cache-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <h4 style="font-size: 14px; color: #333; margin-bottom: 10px;">Relay Proxy Cache</h4>
          <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
            Internal Go SDK cache served to downstream clients
          </div>
          <div id="relay-proxy-cache" style="font-size: 12px; line-height: 1.6; color: #555; max-height: 400px; overflow-y: auto; background-color: #f8f9fa; padding: 10px; border-radius: 4px; transition: max-height 0.3s ease;">
            <div style="color: #999; font-style: italic;">Waiting for Relay Proxy to initialize...</div>
          </div>
        </div>
      </div>

      <!-- Redis Panel -->
      <div class="service-panel" id="redis-panel">
        <div class="service-header">
          <div class="service-header-left">
            <img src="Redis_logo.svg.png" alt="Redis" class="service-logo" />
            <h2>Redis</h2>
          </div>
          <div class="service-header-right">
            <button id="redis-start-button" class="control-icon-button start" title="Start Redis">â–¶</button>
            <button id="redis-stop-button" class="control-icon-button stop" title="Stop Redis">â– </button>
            <button id="redis-restart-button" class="control-icon-button restart" title="Restart Redis">â†»</button>
            <div class="status-indicator" id="redis-status">
              <span class="status-dot red dimmed" id="redis-status-red"></span>
              <span class="status-dot orange dimmed" id="redis-status-orange"></span>
              <span class="status-dot green dimmed" id="redis-status-green"></span>
            </div>
          </div>
        </div>
        
        <div style="margin-bottom: 20px;">
          <div style="font-size: 14px; color: #666; margin-bottom: 10px;">
            <strong>Status:</strong> <span id="redis-status-text">Checking...</span>
          </div>
          <div style="font-size: 14px; color: #666;">
            <strong>Port:</strong> 6379
          </div>
        </div>
        
        <div class="sdk-cache-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <h4 style="font-size: 14px; color: #333; margin-bottom: 10px;">Redis Data Store</h4>
          <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
            Raw flag configurations stored in Redis (context-independent)
          </div>
          <div id="redis-data-store" style="font-size: 12px; line-height: 1.6; color: #555; max-height: 517px; overflow-y: auto; background-color: #f8f9fa; padding: 10px; border-radius: 4px; transition: max-height 0.3s ease;">
            <div style="color: #999; font-style: italic;">Waiting for Redis to initialize...</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Logs Section (Bottom 40%) -->
    <div class="logs-section">
      <!-- Node App Dev Log Console -->
      <div class="log-console" id="node-app-dev-console">
        <div class="log-console-header">
          <h3>node-app-dev</h3>
          <button id="node-app-dev-clear">Clear</button>
        </div>
        <div class="log-console-output" id="node-app-dev-output"></div>
      </div>

      <!-- PHP App Dev Log Console -->
      <div class="log-console" id="php-app-dev-console">
        <div class="log-console-header">
          <h3>php-app-dev</h3>
          <button id="php-app-dev-clear">Clear</button>
        </div>
        <div class="log-console-output" id="php-app-dev-output"></div>
      </div>

      <!-- Relay Proxy Log Console -->
      <div class="log-console" id="relay-proxy-console">
        <div class="log-console-header">
          <h3>relay-proxy</h3>
          <button id="relay-proxy-clear">Clear</button>
        </div>
        <div class="log-console-output" id="relay-proxy-output"></div>
      </div>

      <!-- Redis Monitor Console -->
      <div class="log-console" id="redis-monitor-console">
        <div class="log-console-header">
          <h3>redis-monitor</h3>
          <button id="redis-monitor-clear">Clear</button>
        </div>
        <div class="log-console-output" id="redis-monitor-output"></div>
      </div>

    </div>
  </div>

  <!-- Relay Proxy Status Modal -->
  <div id="relay-status-modal" class="modal">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3>Relay Proxy Status</h3>
      </div>
      <div class="modal-body">
        <div id="relay-status-content">
          <p>Loading status...</p>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn-secondary" id="relay-status-close">Close</button>
      </div>
    </div>
  </div>

  <!-- Load Test Modal -->
  <div id="load-test-modal" class="modal">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3>Load Test</h3>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="load-test-requests">Number of Requests</label>
          <input type="text" id="load-test-requests" placeholder="100" value="100">
        </div>
        
        <div class="form-group">
          <label for="load-test-concurrency">Concurrency</label>
          <input type="text" id="load-test-concurrency" placeholder="10" value="10">
        </div>
        
        <div class="form-group">
          <label for="load-test-service">Target Service</label>
          <div class="radio-group">
            <div class="radio-option">
              <input type="radio" id="load-test-node" name="load-test-service" value="node" checked>
              <label for="load-test-node">Node.js</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="load-test-php" name="load-test-service" value="php">
              <label for="load-test-php">PHP</label>
            </div>
          </div>
        </div>
        
        <div id="load-test-output" style="margin-top: 20px; padding: 10px; background-color: #f5f5f5; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; display: none;">
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn-secondary" id="load-test-close">Close</button>
        <button type="button" class="btn-primary" id="load-test-start">Start Test</button>
      </div>
    </div>
  </div>

  <!-- Context Editor Modal -->
  <div id="context-modal" class="modal">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3>Edit User Context</h3>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Context Type</label>
          <div class="radio-group">
            <div class="radio-option">
              <input type="radio" id="context-type-anonymous" name="context-type" value="anonymous" checked onchange="toggleContextFields()">
              <label for="context-type-anonymous">Anonymous</label>
            </div>
            <div class="radio-option">
              <input type="radio" id="context-type-custom" name="context-type" value="custom" onchange="toggleContextFields()">
              <label for="context-type-custom">Custom</label>
            </div>
          </div>
        </div>
        
        <div id="custom-context-fields" style="display: none;">
          <div class="form-group">
            <label for="context-email">Email</label>
            <input type="email" id="context-email" placeholder="user@example.com">
          </div>
          
          <div class="form-group">
            <label for="context-name">Name</label>
            <input type="text" id="context-name" placeholder="John Doe">
          </div>
        </div>
        
        <div class="form-group">
          <label for="context-location">Location (optional)</label>
          <input type="text" id="context-location" placeholder="Detecting location...">
          <div id="location-status" style="margin-top: 5px; font-size: 12px; color: #666;">Detecting location...</div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn-secondary" id="modal-cancel">Cancel</button>
        <button type="button" class="btn-primary" id="modal-save">Save</button>
      </div>
    </div>
  </div>

  <script>
    // Global error handler to prevent page reloads on errors
    window.addEventListener('error', (event) => {
      console.error('[Dashboard] GLOBAL ERROR:', event.error);
      console.error('[Dashboard] Error message:', event.message);
      console.error('[Dashboard] Error filename:', event.filename);
      console.error('[Dashboard] Error line:', event.lineno);
      // Prevent default behavior (which might cause reload)
      event.preventDefault();
    });
    
    window.addEventListener('unhandledrejection', (event) => {
      console.error('[Dashboard] UNHANDLED PROMISE REJECTION:', event.reason);
      // Prevent default behavior
      event.preventDefault();
    });
    
    // Catch any navigation/reload attempts
    window.addEventListener('beforeunload', (event) => {
      console.error('[Dashboard] ===== PAGE IS ABOUT TO UNLOAD/RELOAD =====');
      console.error('[Dashboard] Stack trace:', new Error().stack);
      // Try to prevent it
      event.preventDefault();
      event.returnValue = '';
      return '';
    });
    
    // Global location variable
    let detectedLocation = '';
    
    // Prevent multiple SDK initializations
    let sdkInitialized = false;
    
    // Function to toggle context fields based on type
    function toggleContextFields() {
      const contextType = document.querySelector('input[name="context-type"]:checked').value;
      const customFields = document.getElementById('custom-context-fields');
      
      if (contextType === 'custom') {
        customFields.style.display = 'block';
      } else {
        customFields.style.display = 'none';
        // Clear custom fields when switching to anonymous
        document.getElementById('context-email').value = '';
        document.getElementById('context-name').value = '';
      }
    }
    
    // Function to detect location automatically
    async function detectLocation() {
      const locationInput = document.getElementById('context-location');
      const locationStatus = document.getElementById('location-status');
      
      // If we already detected location, just populate it
      if (detectedLocation) {
        locationInput.value = detectedLocation;
        locationStatus.textContent = `Location detected (you can edit)`;
        locationStatus.style.color = '#405BFF';
        return;
      }
      
      // Update status to show we're trying
      locationStatus.textContent = 'Detecting location...';
      locationStatus.style.color = '#666';
      
      if ('geolocation' in navigator) {
        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              timeout: 10000,
              maximumAge: 0,
              enableHighAccuracy: false
            });
          });
          
          const latitude = position.coords.latitude;
          const longitude = position.coords.longitude;
          
          try {
            const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`);
            const data = await response.json();
            
            const city = data.address.city || data.address.town || data.address.village || data.address.county;
            const country = data.address.country;
            detectedLocation = city && country ? `${city}, ${country}` : data.display_name;
            
            locationInput.value = detectedLocation;
            locationStatus.textContent = `Location detected: ${detectedLocation} (you can edit)`;
            locationStatus.style.color = '#405BFF';
          } catch (error) {
            console.error('Geocoding error:', error);
            detectedLocation = `${latitude.toFixed(4)}, ${longitude.toFixed(4)}`;
            locationInput.value = detectedLocation;
            locationStatus.textContent = `Location detected: ${detectedLocation} (you can edit)`;
            locationStatus.style.color = '#405BFF';
          }
        } catch (error) {
          console.error('Geolocation error:', error);
          
          // Make field editable and provide helpful message
          locationInput.placeholder = 'Enter your location (e.g., San Francisco, CA)';
          
          // Determine error type - but keep message friendly
          let errorMsg = '';
          if (error.code === 1) {
            errorMsg = 'Location auto-detection not permitted';
          } else if (error.code === 2) {
            errorMsg = 'Location auto-detection unavailable';
          } else if (error.code === 3) {
            errorMsg = 'Location detection timed out';
          } else {
            errorMsg = 'Location auto-detection not available';
          }
          
          locationStatus.innerHTML = `<span style="color: #666;">${errorMsg}</span> - <span style="color: #405BFF;">Enter manually</span> <span style="font-size: 11px; color: #999;">(optional)</span>`;
        }
      } else {
        locationInput.placeholder = 'Enter your location (e.g., San Francisco, CA)';
        locationStatus.innerHTML = '<span style="color: #666;">Location auto-detection not supported</span> - <span style="color: #405BFF;">Enter manually</span> <span style="font-size: 11px; color: #999;">(optional)</span>';
      }
    }
    
    // RelayProxyConnectionControl class for managing relay proxy connection toggle
    class RelayProxyConnectionControl {
      constructor() {
        this.toggle = document.getElementById('relay-connection-toggle');
        this.statusText = document.getElementById('connection-status-text');
        this.errorDiv = document.getElementById('connection-error');
        this.isUpdating = false;
        this.pollingInterval = null;
        
        // Verify elements exist
        if (!this.toggle) {
          console.error('[RelayProxyConnectionControl] Toggle element not found');
          return;
        }
        if (!this.statusText) {
          console.error('[RelayProxyConnectionControl] Status text element not found');
          return;
        }
        if (!this.errorDiv) {
          console.error('[RelayProxyConnectionControl] Error div element not found');
          return;
        }
        
        this.init();
      }
      
      async init() {
        // Load initial connection status
        await this.loadConnectionStatus();
        
        // Set up toggle event listener (only if toggle exists)
        if (this.toggle) {
          this.toggle.addEventListener('change', (e) => this.handleToggle(e));
        }
        
        // Poll for status updates every 5 seconds
        this.pollingInterval = setInterval(() => this.loadConnectionStatus(), 5000);
      }
      
      async loadConnectionStatus() {
        try {
          const response = await fetch('http://localhost:4000/api/relay-proxy/connection-status');
          const data = await response.json();
          
          this.updateUI(data.connected, data.containerRunning);
        } catch (error) {
          console.error('Failed to load connection status:', error);
          this.showError('Failed to load connection status');
        }
      }
      
      async handleToggle(event) {
        if (this.isUpdating) {
          event.preventDefault();
          return;
        }
        
        this.isUpdating = true;
        this.hideError();
        
        const shouldConnect = event.target.checked;
        const endpoint = shouldConnect 
          ? '/api/relay-proxy/reconnect'
          : '/api/relay-proxy/disconnect';
        
        try {
          const response = await fetch(`http://localhost:4000${endpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          const data = await response.json();
          
          if (!data.success) {
            throw new Error(data.error || 'Operation failed');
          }
          
          // Update UI to reflect new state
          this.updateUI(shouldConnect, true);
          
        } catch (error) {
          console.error('Connection toggle failed:', error);
          this.showError(error.message);
          
          // Revert toggle to previous state
          event.target.checked = !shouldConnect;
          
        } finally {
          this.isUpdating = false;
        }
      }
      
      updateUI(connected, containerRunning) {
        if (!this.toggle || !this.statusText) {
          console.error('[RelayProxyConnectionControl] Cannot update UI - elements not found');
          return;
        }
        
        if (!containerRunning) {
          this.toggle.disabled = true;
          this.toggle.checked = false;
          this.statusText.textContent = 'Container Stopped';
          this.statusText.className = 'status-text stopped';
          return;
        }
        
        this.toggle.disabled = false;
        this.toggle.checked = connected;
        this.statusText.textContent = connected ? 'Connected' : 'Disconnected';
        this.statusText.className = connected 
          ? 'status-text connected' 
          : 'status-text disconnected';
      }
      
      showError(message) {
        if (this.errorDiv) {
          this.errorDiv.textContent = message;
          this.errorDiv.style.display = 'block';
        }
      }
      
      hideError() {
        if (this.errorDiv) {
          this.errorDiv.style.display = 'none';
        }
      }
    }
    
    // LogConsole class for managing log console displays
    class LogConsole {
      constructor(containerId, elementId, updateMethod) {
        this.containerId = containerId;
        this.elementId = elementId;
        this.updateMethod = updateMethod; // 'polling' or 'sse'
        this.maxLines = 50;
        this.lines = [];
        this.eventSource = null;
        this.pollingInterval = null;
      }
      
      // Start log streaming
      start() {
        if (this.updateMethod === 'sse') {
          this.startSSE();
        } else {
          this.startPolling();
        }
      }
      
      // Start SSE connection (for Redis monitor)
      startSSE() {
        this.eventSource = new EventSource(`http://localhost:4000/api/redis/monitor`);
        this.eventSource.onmessage = (event) => {
          const data = JSON.parse(event.data);
          // Filter out PING commands (data.command for Redis monitor, data.message for others)
          const content = data.command || data.message || '';
          if (!content.toLowerCase().includes('"ping"')) {
            this.appendLine(content);
          }
        };
        
        this.eventSource.onerror = (error) => {
          console.error(`SSE error for ${this.containerId}:`, error);
          // Close and attempt to reconnect
          if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
          }
          // Reconnect after 5 seconds
          setTimeout(() => {
            this.startSSE();
          }, 5000);
        };
      }
      
      // Start polling (for Docker logs)
      startPolling() {
        const poll = async () => {
          try {
            const response = await fetch(`http://localhost:4000/api/logs/${this.containerId}`);
            const data = await response.json();
            if (data.lines && Array.isArray(data.lines)) {
              this.setLines(data.lines);
            }
          } catch (error) {
            console.error(`Error polling logs for ${this.containerId}:`, error);
          }
        };
        
        // Poll immediately, then every 2 seconds
        poll();
        this.pollingInterval = setInterval(poll, 2000);
      }
      
      // Append a single line
      appendLine(line) {
        this.lines.push(line);
        if (this.lines.length > this.maxLines) {
          this.lines.shift();
        }
        this.render();
      }
      
      // Set all lines (for polling)
      setLines(lines) {
        this.lines = lines.slice(-this.maxLines);
        this.render();
      }
      
      // Render lines to DOM
      render() {
        const element = document.getElementById(this.elementId);
        if (!element) {
          console.error(`Element ${this.elementId} not found`);
          return;
        }
        
        element.innerHTML = this.lines.map(line => {
          const timestamp = new Date().toLocaleTimeString();
          return `<div class="log-line">[${timestamp}] ${this.escapeHtml(line)}</div>`;
        }).join('');
        
        // Auto-scroll to bottom
        element.scrollTop = element.scrollHeight;
      }
      
      // Escape HTML to prevent XSS
      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      // Clear console
      async clear() {
        // Clear the display immediately
        this.lines = [];
        this.render();
        
        // Call backend to actually clear the Docker container logs
        // (only for Docker log consoles, not for Redis monitor which uses SSE)
        if (this.updateMethod === 'polling') {
          try {
            const response = await fetch(`http://localhost:4000/api/logs/${this.containerId}/clear`, {
              method: 'POST'
            });
            
            if (response.ok) {
              const data = await response.json();
              console.log(`Container logs cleared: ${data.message}`);
            } else {
              const error = await response.json();
              console.error(`Failed to clear container logs: ${error.error}`);
            }
          } catch (error) {
            console.error(`Error clearing container logs for ${this.containerId}:`, error);
          }
        }
      }
      
      // Stop streaming/polling
      stop() {
        if (this.eventSource) {
          this.eventSource.close();
          this.eventSource = null;
        }
        if (this.pollingInterval) {
          clearInterval(this.pollingInterval);
          this.pollingInterval = null;
        }
      }
    }

    // ContextEditorModal class for managing context editor modal
    class ContextEditorModal {
      constructor(servicePanel) {
        this.servicePanel = servicePanel;
        this.modalElement = null;
      }
      
      // Open modal with current context
      open() {
        this.modalElement = document.getElementById('context-modal');
        if (!this.modalElement) {
          console.error('Context modal element not found');
          return;
        }
        
        this.populateForm(this.servicePanel.currentContext);
        this.modalElement.classList.add('show');
        
        // Set the modal's service ID for reference
        this.modalElement.dataset.serviceId = this.servicePanel.serviceId;
        
        // Automatically detect location when modal opens
        detectLocation();
      }
      
      // Close modal
      close() {
        if (this.modalElement) {
          this.modalElement.classList.remove('show');
        }
      }
      
      // Populate form with context data
      populateForm(context) {
        // Determine if context is anonymous
        // Support both formats: context.type === 'anonymous' OR context.anonymous === true
        const isAnonymous = context.type === 'anonymous' || context.anonymous === true;
        
        if (isAnonymous) {
          const anonymousRadio = document.getElementById('context-type-anonymous');
          if (anonymousRadio) {
            anonymousRadio.checked = true;
          }
          // Hide custom fields for anonymous
          toggleContextFields();
          
          // Set location if available
          const locationInput = document.getElementById('context-location');
          if (locationInput && context.location) {
            locationInput.value = context.location;
          }
        } else {
          const customRadio = document.getElementById('context-type-custom');
          if (customRadio) {
            customRadio.checked = true;
          }
          // Show custom fields
          toggleContextFields();
          
          // Populate custom fields
          const emailInput = document.getElementById('context-email');
          const nameInput = document.getElementById('context-name');
          const locationInput = document.getElementById('context-location');
          if (emailInput) emailInput.value = context.email || '';
          if (nameInput) nameInput.value = context.name || '';
          if (locationInput) locationInput.value = context.location || '';
        }
      }
      
      // Validate email format
      validateEmail(email) {
        if (!email) return true; // Empty is valid for anonymous
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      }
      
      // Save context
      async save() {
        console.log('ContextEditorModal.save() called');
        
        const typeRadio = document.querySelector('input[name="context-type"]:checked');
        if (!typeRadio) {
          alert('Please select a context type');
          return;
        }
        
        const type = typeRadio.value;
        console.log('Context type:', type);
        
        const context = { type };
        
        // Get location field (available for both anonymous and custom)
        const locationInput = document.getElementById('context-location');
        const location = locationInput ? locationInput.value.trim() : '';
        
        if (type === 'custom') {
          const emailInput = document.getElementById('context-email');
          const nameInput = document.getElementById('context-name');
          
          const email = emailInput ? emailInput.value.trim() : '';
          const name = nameInput ? nameInput.value.trim() : '';
          
          console.log('Custom context - email:', email, 'name:', name, 'location:', location);
          
          // Email is required for custom context
          if (!email) {
            alert('Email is required for custom context');
            return;
          }
          
          // Validate email format
          if (!this.validateEmail(email)) {
            alert('Please enter a valid email address');
            return;
          }
          
          context.email = email;
          context.name = name;
          if (location) {
            context.location = location;
          }
        } else {
          // Anonymous context
          console.log('Anonymous context - location:', location);
          if (location) {
            context.location = location;
          }
        }
        
        console.log('Saving context:', context);
        const success = await this.servicePanel.saveContext(context);
        console.log('Save result:', success);
        
        if (success) {
          this.close();
        }
      }
    }

    // ServicePanel class for managing individual service panels
    class ServicePanel {
      constructor(serviceId, apiBaseUrl) {
        this.serviceId = serviceId; // 'node' or 'php'
        this.apiBaseUrl = apiBaseUrl;
        this.eventSource = null;
        
        // Configure cache endpoint per service
        // Node uses 'sdk-cache' (raw data store), Python uses 'sdk-data-store', PHP uses 'redis-cache' (Redis data store)
        this.cacheEndpoint = serviceId === 'node' ? 'sdk-cache' : serviceId === 'python' ? 'sdk-data-store' : 'redis-cache';
        
        // Track SDK connection status
        this.isConnected = false;
        this.wasConnected = false; // Track previous connection state
        this.currentContext = null; // Will be loaded from server
        this.reconnectAttempts = 0;
        this.reconnectTimeout = null;
        this.maxReconnectDelay = 60000; // 60 seconds max
        this.statusPollingInterval = null;
      }
      
      // Connect to SSE stream for real-time flag updates
      connectStream() {
        // Pass context key in URL so SSE endpoint can look up context from in-memory store
        const contextKey = this.currentContext?.key || 'unknown';
        const url = `${this.apiBaseUrl}/message/stream?contextKey=${encodeURIComponent(contextKey)}`;
        console.log(`[${this.serviceId}] Connecting to SSE stream: ${url}`);
        this.eventSource = new EventSource(url);
        
        this.eventSource.onmessage = (event) => {
          console.log(`[${this.serviceId}] SSE message received:`, event.data);
          const data = JSON.parse(event.data);
          console.log(`[${this.serviceId}] Parsed message:`, data.message);
          this.updateFlagValue(data.message);
          
          // Update hash info if available
          if (data.hashInfo) {
            this.updateHashInfo(data.hashInfo);
          }
          
          // Reset reconnect attempts on successful message
          this.reconnectAttempts = 0;
        };
        
        this.eventSource.onerror = (error) => {
          console.error(`SSE error for ${this.serviceId}:`, error);
          this.updateStatusIndicator(false);
          this.updateFlagValue('Service unavailable');
          
          // Close the current connection
          if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
          }
          
          // Attempt to reconnect with exponential backoff
          this.scheduleReconnect();
        };
        
        this.eventSource.onopen = () => {
          console.log(`SSE connection opened for ${this.serviceId}`);
          this.updateStatusIndicator(true);
          // Reset reconnect attempts on successful connection
          this.reconnectAttempts = 0;
        };
      }
      
      // Schedule reconnection with exponential backoff
      scheduleReconnect() {
        // Clear any existing reconnect timeout
        if (this.reconnectTimeout) {
          clearTimeout(this.reconnectTimeout);
        }
        
        // Calculate delay: 5s, 10s, 20s, 40s, max 60s
        const baseDelay = 5000; // 5 seconds
        const delay = Math.min(
          baseDelay * Math.pow(2, this.reconnectAttempts),
          this.maxReconnectDelay
        );
        
        console.log(`Scheduling reconnect for ${this.serviceId} in ${delay}ms (attempt ${this.reconnectAttempts + 1})`);
        
        this.reconnectTimeout = setTimeout(() => {
          this.reconnectAttempts++;
          console.log(`Attempting to reconnect ${this.serviceId} (attempt ${this.reconnectAttempts})`);
          this.connectStream();
        }, delay);
      }
      
      // Update status indicator
      updateStatusIndicator(connected) {
        const status = connected ? 'connected' : 'disconnected';
        updatePillStatus(this.serviceId, status);
      }
      
      // Update the displayed feature flag value
      updateFlagValue(value) {
        const flagElement = document.getElementById(`${this.serviceId}-flag-value`);
        if (flagElement) {
          const previousValue = flagElement.textContent;
          flagElement.textContent = value;
          
          // If the flag value changed (and it's not an error message), auto-refresh cache
          // BUT: PHP cache is updated via Relay Proxy SSE, Python uses fetchPythonSDKData(), so skip auto-refresh for both
          if (this.serviceId !== 'php' && this.serviceId !== 'python' &&
              previousValue !== value && 
              value !== 'Loading...' && 
              value !== 'Service unavailable' &&
              previousValue !== 'Loading...') {
            console.log(`[${this.serviceId}] Flag value changed, auto-refreshing cache`);
            this.fetchAndDisplayCache();
          }
        }
      }
      
      // Update the displayed hash information
      updateHashInfo(hashInfo) {
        const hashElement = document.getElementById(`${this.serviceId}-hash-info`);
        if (hashElement && hashInfo) {
          let html = '';
          html += `<div style="margin-bottom: 4px;"><strong>Context Key:</strong> ${this.escapeHtml(this.currentContext.key || 'N/A')}</div>`;
          html += `<div style="margin-bottom: 4px;"><strong>Salt:</strong> ${this.escapeHtml(hashInfo.salt || 'N/A')}</div>`;
          html += `<div style="margin-bottom: 4px;"><strong>Hash Value:</strong> <span style="color: #405BFF;">${hashInfo.hashValue}</span></div>`;
          html += `<div><strong>Bucket Value:</strong> <span style="color: #4caf50; font-weight: 600;">${hashInfo.bucketValue.toFixed(5)}</span></div>`;
          html += `<div style="margin-top: 6px; font-size: 11px; color: #666; font-style: italic;">Bucket determines which variation the user receives in percentage rollouts</div>`;
          hashElement.innerHTML = html;
        }
      }
      
      // Open context editor modal
      openContextEditor() {
        if (!this.contextModal) {
          this.contextModal = new ContextEditorModal(this);
        }
        this.contextModal.open();
      }
      
      // Save new context and reconnect stream
      async saveContext(context) {
        try {
          const response = await fetch(`${this.apiBaseUrl}/context`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',  // Use same session as SSE stream
            body: JSON.stringify(context)
          });
          
          if (response.ok) {
            const data = await response.json();
            
            // Use the context returned from the server to ensure we have what was actually saved
            if (data.context) {
              this.currentContext = data.context;
              console.log(`Context saved successfully for ${this.serviceId}:`, this.currentContext);
            } else {
              // Fallback to the context we sent if server doesn't return it
              this.currentContext = context;
            }
            
            this.updateContextDisplay();
            this.reconnectStream();
            
            // Automatically refresh the flags cache after context change
            // PHP cache is updated via Relay Proxy SSE, so skip for PHP
            // Python uses its own fetchPythonSDKData() function, so skip for Python
            if (this.serviceId !== 'php' && this.serviceId !== 'python') {
              await this.fetchAndDisplayCache();
            }
            
            // For Python, call the dedicated fetch function
            if (this.serviceId === 'python') {
              await fetchPythonSDKData();
            }
            
            // Show success message with context details
            const contextDetails = [];
            if (this.currentContext.type === 'anonymous') {
              contextDetails.push('Type: Anonymous');
            } else {
              contextDetails.push('Type: Custom');
              if (this.currentContext.email) contextDetails.push(`Email: ${this.currentContext.email}`);
              if (this.currentContext.name) contextDetails.push(`Name: ${this.currentContext.name}`);
            }
            if (this.currentContext.location) {
              contextDetails.push(`Location: ${this.currentContext.location} âœ“`);
            }
            
            console.log(`âœ“ Context updated:\n${contextDetails.join('\n')}`);
            return true;
          } else {
            const errorData = await response.json().catch(() => ({}));
            const errorMessage = errorData.error || `Failed to save context (${response.status})`;
            console.error(`Failed to save context for ${this.serviceId}:`, errorMessage);
            alert(`Failed to save context: ${errorMessage}`);
            return false;
          }
        } catch (error) {
          console.error(`Error saving context for ${this.serviceId}:`, error);
          alert(`Error saving context: ${error.message}`);
          return false;
        }
      }
      
      // Update the context display in the UI
      updateContextDisplay() {
        // Don't update if context hasn't been loaded yet
        if (!this.currentContext) {
          return;
        }
        
        // Update type
        const contextTypeElement = document.getElementById(`${this.serviceId}-context-type`);
        if (contextTypeElement) {
          // Check both 'type' field (Node.js/PHP format) and 'anonymous' field (Python format)
          const isAnonymous = this.currentContext.type === 'anonymous' || this.currentContext.anonymous === true;
          contextTypeElement.textContent = isAnonymous ? 'Anonymous' : 'Custom';
        }
        
        // Update key
        const contextKeyElement = document.getElementById(`${this.serviceId}-context-key`);
        if (contextKeyElement) {
          contextKeyElement.textContent = this.currentContext.key || 'Not set';
        }
        
        // Update attributes
        const contextAttributesElement = document.getElementById(`${this.serviceId}-context-attributes`);
        if (contextAttributesElement) {
          const attributes = [];
          
          if (this.currentContext.email) {
            attributes.push(`<div><strong>Email:</strong> ${this.escapeHtml(this.currentContext.email)}</div>`);
          }
          if (this.currentContext.name) {
            attributes.push(`<div><strong>Name:</strong> ${this.escapeHtml(this.currentContext.name)}</div>`);
          }
          // Check for location as top-level attribute (Python/Node.js format)
          if (this.currentContext.location) {
            attributes.push(`<div><strong>Location:</strong> ðŸ“ ${this.escapeHtml(this.currentContext.location)}</div>`);
          }
          
          if (attributes.length > 0) {
            contextAttributesElement.innerHTML = attributes.join('');
            contextAttributesElement.style.display = 'block';
          } else {
            contextAttributesElement.innerHTML = '<div style="color: #999; font-style: italic;">No additional attributes</div>';
            contextAttributesElement.style.display = 'block';
          }
        }
      }
      
      // Escape HTML to prevent XSS
      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      // Reconnect SSE stream with new context
      reconnectStream() {
        // Clear any pending reconnect timeout
        if (this.reconnectTimeout) {
          clearTimeout(this.reconnectTimeout);
          this.reconnectTimeout = null;
        }
        
        // Reset reconnect attempts
        this.reconnectAttempts = 0;
        
        // Close existing connection
        if (this.eventSource) {
          this.eventSource.close();
          this.eventSource = null;
        }
        
        // Establish new connection
        this.connectStream();
      }
      
      // Poll service status
      async pollStatus() {
        try {
          const response = await fetch(`http://localhost:4000/api/${this.serviceId}/status`);
          const data = await response.json();
          
          // Update status indicator based on health
          this.updateStatusIndicator(data.connected);
          
          // Track connection status
          this.isConnected = data.connected;
          
          // Update cache button state based on connection
          this.updateCacheButtonState();
          
          // Update SDK mode display
          const sdkModeElement = document.getElementById(`${this.serviceId}-sdk-mode`);
          if (sdkModeElement && data.mode) {
            sdkModeElement.textContent = data.mode;
          }
          
        } catch (error) {
          console.error(`Error polling status for ${this.serviceId}:`, error);
          this.updateStatusIndicator(false);
          this.isConnected = false;
          this.updateCacheButtonState();
        }
      }
      
      // Update cache display state based on SDK connection
      updateCacheButtonState() {
        const cacheElement = document.getElementById(`${this.serviceId}-sdk-cache`);
        
        if (!cacheElement) return;
        
        const previousConnectionState = this.wasConnected;
        this.wasConnected = this.isConnected;
        
        if (this.isConnected) {
          // SDK is connected - fetch and display cache
          if (this.serviceId === 'php') {
            // For PHP, manually fetch cache when transitioning from disconnected to connected
            const needsRefresh = !previousConnectionState && this.isConnected && 
                (cacheElement.innerHTML.includes('SDK must be initialized') || 
                 cacheElement.innerHTML.includes('Waiting for SDK'));
            
            if (needsRefresh) {
              this.fetchPHPCache();
            }
          } else if (this.serviceId === 'python') {
            // For Python, use the global fetchPythonSDKData function
            if (cacheElement && 
                (cacheElement.innerHTML.includes('SDK must be initialized') || 
                 cacheElement.innerHTML.includes('Waiting for SDK') ||
                 cacheElement.innerHTML.includes('Loading...'))) {
              fetchPythonSDKData();
            }
          } else {
            // For Node.js, fetch cache if showing error message
            if (cacheElement && 
                (cacheElement.innerHTML.includes('SDK must be initialized') || 
                 cacheElement.innerHTML.includes('Waiting for SDK'))) {
              this.fetchAndDisplayCache();
            }
          }
        } else {
          // SDK not connected - show message
          if (cacheElement && !cacheElement.innerHTML.includes('Waiting for SDK')) {
            console.log(`[${this.serviceId}] Setting disconnected message`);
            cacheElement.innerHTML = '<div style="color: #999; font-style: italic;">SDK must be initialized to view cache</div>';
          }
        }
      }
      
      // Fetch PHP cache from Redis via API
      async fetchPHPCache() {
        try {
          const response = await fetch('http://localhost:4000/api/php/redis-cache', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.success && data.flags) {
              console.log('[PHP] Cache fetched successfully:', Object.keys(data.flags).length, 'flags');
              window.renderPHPSDKCache(data.flags);
            }
          }
        } catch (error) {
          console.error('[PHP] Error fetching cache:', error);
        }
      }
      
      // Fetch current context from server
      async fetchCurrentContext() {
        try {
          const response = await fetch(`${this.apiBaseUrl}/context`, {
            credentials: 'include'  // Use same session as SSE stream
          });
          if (response.ok) {
            const context = await response.json();
            const contextChanged = JSON.stringify(this.currentContext) !== JSON.stringify(context);
            this.currentContext = context;
            this.updateContextDisplay();
            console.log(`[${this.serviceId}] Current context loaded:`, context);
            
            // If context changed and SSE is already connected, reconnect to use new context
            if (contextChanged && this.eventSource) {
              console.log(`[${this.serviceId}] Context changed, reconnecting SSE stream`);
              this.reconnectStream();
            }
          } else {
            console.error(`Failed to fetch context for ${this.serviceId}`);
            this.updateFlagValue('Service unavailable');
            // Update context display to show error state
            const contextKeyElement = document.getElementById(`${this.serviceId}-context-key`);
            if (contextKeyElement) {
              contextKeyElement.textContent = 'Service unavailable';
            }
          }
        } catch (error) {
          console.error(`Error fetching context for ${this.serviceId}:`, error);
          this.updateFlagValue('Service unavailable');
          // Update context display to show error state
          const contextKeyElement = document.getElementById(`${this.serviceId}-context-key`);
          if (contextKeyElement) {
            contextKeyElement.textContent = 'Service unavailable';
          }
        }
      }
      
      // Start status polling (every 5 seconds)
      startStatusPolling() {
        // Poll status immediately
        this.pollStatus();
        
        // Fetch current context from server
        this.fetchCurrentContext();
        
        // Then poll every 5 seconds
        this.statusPollingInterval = setInterval(() => {
          this.pollStatus();
        }, 5000);
      }
      
      // Stop status polling
      stopStatusPolling() {
        if (this.statusPollingInterval) {
          clearInterval(this.statusPollingInterval);
          this.statusPollingInterval = null;
        }
      }
      
      // Fetch and display SDK cache (data store)
      async fetchAndDisplayCache() {
        const cacheElement = document.getElementById(`${this.serviceId}-sdk-cache`);
        
        if (!cacheElement) {
          console.error(`Cache element not found for ${this.serviceId}`);
          return;
        }
        
        // Show loading state
        cacheElement.innerHTML = '<div style="color: #999; font-style: italic;">Loading...</div>';
        
        try {
          // No context needed - data store is context-independent
          const response = await fetch(`${this.apiBaseUrl}/${this.cacheEndpoint}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({})
          });
          
          const data = await response.json();
          
          if (!response.ok || !data.success) {
            // Show the actual error message from the server
            const errorMsg = data.error || `HTTP ${response.status}`;
            cacheElement.innerHTML = `<div style="color: #f44336;">Error: ${errorMsg}</div>`;
            return;
          }
          
          if (data.flags) {
            const flags = data.flags;
            const flagKeys = Object.keys(flags);
            
            let html = '';
            
            if (flagKeys.length === 0) {
              html += '<div style="color: #999; font-style: italic;">No flags in data store</div>';
            } else {
              html += '<div style="font-family: monospace;">';
              flagKeys.forEach(key => {
                const flagValue = flags[key];
                
                console.log('[Dashboard] Processing flag:', key, 'has variations:', !!flagValue.variations, 'length:', flagValue.variations?.length);
                
                // Check if this is a complex configuration object or a simple value
                const isComplexConfig = flagValue && typeof flagValue === 'object' && flagValue.version !== undefined;
                
                html += `<div style="margin-bottom: 12px; padding: 8px; background-color: white; border-radius: 3px; border: 1px solid #e0e0e0;">`;
                html += `<div style="margin-bottom: 4px;"><strong style="color: #405BFF;">${this.escapeHtml(key)}</strong></div>`;
                
                if (isComplexConfig) {
                  // Display raw flag configuration structure
                  html += `<div style="font-size: 11px; color: #666; line-height: 1.8;">`;
                  html += `<div>Version: <span style="color: #333;">${flagValue.version || 'N/A'}</span></div>`;
                  html += `<div>Enabled: <span style="color: #333;">${flagValue.on ? 'Yes' : 'No'}</span></div>`;
                  
                  if (flagValue.variations && flagValue.variations.length > 0) {
                    html += `<div style="margin-top: 6px;"><strong>Variations (${flagValue.variations.length}):</strong></div>`;
                    flagValue.variations.forEach((variation, index) => {
                      const varValue = typeof variation === 'object' ? JSON.stringify(variation) : variation;
                      html += `<div style="margin-left: 12px; font-size: 10px;">`;
                      html += `[${index}]: <span style="color: #405BFF; font-weight: 500;">${this.escapeHtml(varValue)}</span>`;
                      html += `</div>`;
                    });
                  }
                  
                  if (flagValue.fallthrough) {
                    if (flagValue.fallthrough.variation !== undefined) {
                      // Simple fallthrough
                      html += `<div style="margin-top: 6px;">Default (fallthrough): <span style="color: #333;">variation ${flagValue.fallthrough.variation}</span></div>`;
                    } else if (flagValue.fallthrough.rollout) {
                      // Percentage rollout
                      html += `<div style="margin-top: 6px;"><strong>Default (rollout):</strong></div>`;
                      const rollout = flagValue.fallthrough.rollout;
                      if (rollout.variations) {
                        rollout.variations.forEach((rv) => {
                          const percentage = (rv.weight / 1000).toFixed(1);
                          html += `<div style="margin-left: 12px; font-size: 10px;">`;
                          html += `Variation ${rv.variation}: ${percentage}%`;
                          html += `</div>`;
                        });
                      }
                    }
                  }
                  
                  if (flagValue.offVariation !== undefined) {
                    html += `<div>Off variation: <span style="color: #333;">variation ${flagValue.offVariation}</span></div>`;
                  }
                  
                  if (flagValue.rules && flagValue.rules.length > 0) {
                    html += `<div style="margin-top: 6px;"><strong>Rules (${flagValue.rules.length}):</strong></div>`;
                    flagValue.rules.forEach((rule, index) => {
                      html += `<div style="margin-left: 12px; font-size: 10px; margin-bottom: 4px;">`;
                      html += `<strong>Rule ${index + 1}:</strong>`;
                      
                      // Show variation or rollout
                      if (rule.variation !== undefined) {
                        html += ` â†’ Variation ${rule.variation}`;
                      } else if (rule.rollout) {
                        html += ` â†’ Rollout`;
                      }
                      
                      // Show clauses
                      if (rule.clauses && rule.clauses.length > 0) {
                        html += `<div style="margin-left: 12px; margin-top: 2px;">`;
                        rule.clauses.forEach((clause, clauseIndex) => {
                          const negateText = clause.negate ? 'NOT ' : '';
                          const attribute = clause.attribute || 'key';
                          const op = clause.op || 'unknown';
                          const values = clause.values || [];
                          
                          html += `<div style="color: #666;">`;
                          html += `${negateText}${attribute} ${op} `;
                          
                          if (values.length === 1) {
                            html += `"${this.escapeHtml(values[0])}"`;
                          } else if (values.length > 1) {
                            html += `[${values.map(v => `"${this.escapeHtml(v)}"`).join(', ')}]`;
                          }
                          
                          html += `</div>`;
                        });
                        html += `</div>`;
                      }
                      
                      html += `</div>`;
                    });
                  }
                  
                  if (flagValue.targets && flagValue.targets.length > 0) {
                    html += `<div style="margin-top: 6px;"><strong>Targets (${flagValue.targets.length}):</strong></div>`;
                    flagValue.targets.forEach((target) => {
                      const userCount = target.values ? target.values.length : 0;
                      html += `<div style="margin-left: 12px; font-size: 10px;">`;
                      html += `Variation ${target.variation}: ${userCount} user(s)`;
                      if (target.values && target.values.length > 0 && target.values.length <= 5) {
                        // Show user keys if there are 5 or fewer
                        html += ` - ${target.values.map(v => this.escapeHtml(v)).join(', ')}`;
                      } else if (target.values && target.values.length > 5) {
                        // Show first 5 and indicate there are more
                        html += ` - ${target.values.slice(0, 5).map(v => this.escapeHtml(v)).join(', ')}, ...`;
                      }
                      html += `</div>`;
                    });
                  }
                  
                  if (flagValue.prerequisites && flagValue.prerequisites.length > 0) {
                    html += `<div style="margin-top: 6px;"><strong>Prerequisites (${flagValue.prerequisites.length}):</strong></div>`;
                    flagValue.prerequisites.forEach((prereq, index) => {
                      html += `<div style="margin-left: 12px; font-size: 10px;">`;
                      html += `${prereq.key} must be variation ${prereq.variation}`;
                      html += `</div>`;
                    });
                  }
                  
                  html += `</div>`;
                } else {
                  // Display simple cached value (streaming mode)
                  html += `<div style="font-size: 11px; color: #666; line-height: 1.8;">`;
                  html += `<div>Cached Value: <span style="color: #333; font-weight: 500;">${this.escapeHtml(JSON.stringify(flagValue))}</span></div>`;
                  html += `<div style="font-size: 10px; color: #999; margin-top: 4px;">Streaming mode: showing evaluated value</div>`;
                  html += `</div>`;
                }
                
                html += `</div>`;
              });
              html += '</div>';
            }
            cacheElement.innerHTML = html;
          } else {
            cacheElement.innerHTML = `<div style="color: #f44336;">Error: ${data.error || 'Failed to fetch flags'}</div>`;
          }
        } catch (error) {
          console.error(`Error fetching SDK cache for ${this.serviceId}:`, error);
          cacheElement.innerHTML = `<div style="color: #f44336;">Error: ${error.message}</div>`;
        }
      }
    }

    // Initialize service panels when DOM is loaded
    let nodePanel, phpPanel, pythonPanel;
    let appDevConsole, phpAppDevConsole, relayProxyConsole, redisMonitorConsole;
    
    // Helper function to update pill status indicator
    function updatePillStatus(serviceId, status) {
      const redDot = document.getElementById(`${serviceId}-status-red`);
      const orangeDot = document.getElementById(`${serviceId}-status-orange`);
      const greenDot = document.getElementById(`${serviceId}-status-green`);
      
      if (!redDot || !orangeDot || !greenDot) return;
      
      // Dim all dots first
      redDot.classList.add('dimmed');
      orangeDot.classList.add('dimmed');
      greenDot.classList.add('dimmed');
      
      // Brighten the active status
      if (status === 'disconnected' || status === 'stopped') {
        redDot.classList.remove('dimmed');
      } else if (status === 'degraded') {
        orangeDot.classList.remove('dimmed');
      } else if (status === 'connected' || status === 'running') {
        greenDot.classList.remove('dimmed');
      }
    }
    
    // Fetch panel configuration from feature flag
    // Returns "node.js" or "python" based on the dashboard-service-panel-1 flag
    // Falls back to "node.js" on error
    // Fetch panel configuration from LaunchDarkly via backend API
    // Uses boolean flag 'dashboard-service-panel-1' (string flags cause page reload bug in SDK)
    // Returns "node" or "python" for internal use
    // Falls back to "node" on error
    // Requirements: 2.5, 2.6, 4.1
    async function fetchPanelConfiguration() {
      try {
        const response = await fetch('http://localhost:4000/api/flag/dashboard-service-panel-1');
        const data = await response.json();
        // Convert boolean to service name: true = python, false = node
        return data.value === true ? 'python' : 'node';
      } catch (error) {
        console.error('Error fetching panel configuration:', error);
        return 'node';  // Default fallback
      }
    }
    
    // Helper function to escape HTML (prevent XSS)
    function escapeHtml(text) {
      if (text === null || text === undefined) return '';
      const div = document.createElement('div');
      div.textContent = String(text);
      return div.innerHTML;
    }
    
    // Python service SSE connection
    let pythonSSE = null;
    
    // Update terminal panel 1 to show the correct service logs
    // Requirements: 2.5, 2.6
    function updateTerminalPanel1(serviceType) {
      // Try to find the console element by either possible ID
      let consoleElement = document.getElementById('node-app-dev-console');
      if (!consoleElement) {
        consoleElement = document.getElementById('python-app-dev-console');
      }
      
      if (!consoleElement) {
        console.error('Terminal panel 1 not found (tried both node-app-dev-console and python-app-dev-console)');
        return;
      }
      
      // Update the panel header and IDs based on service type
      if (serviceType === 'python') {
        consoleElement.id = 'python-app-dev-console';
        const header = consoleElement.querySelector('h3');
        if (header) header.textContent = 'python-app-dev';
        
        const clearBtn = consoleElement.querySelector('button');
        if (clearBtn) clearBtn.id = 'python-app-dev-clear';
        
        const output = consoleElement.querySelector('.log-console-output');
        if (output) output.id = 'python-app-dev-output';
      } else {
        // Ensure it's set to node (default)
        consoleElement.id = 'node-app-dev-console';
        const header = consoleElement.querySelector('h3');
        if (header) header.textContent = 'node-app-dev';
        
        const clearBtn = consoleElement.querySelector('button');
        if (clearBtn) clearBtn.id = 'node-app-dev-clear';
        
        const output = consoleElement.querySelector('.log-console-output');
        if (output) output.id = 'node-app-dev-output';
      }
    }
    
    // Initialize Node.js service panel (restore original HTML)
    // Requirements: 2.6, 4.3, 4.5
    async function initializeNodePanel() {
      const panel = document.getElementById('node-service-panel');
      if (!panel) {
        console.error('Panel 1 not found');
        return;
      }
      
      // Restore original Node.js panel HTML
      panel.innerHTML = `
        <div class="service-header">
          <div class="service-header-left">
            <img src="Node.js_logo.svg.png" alt="Node.js" class="service-logo" />
            <h2>Node.js Service</h2>
          </div>
          <div class="service-header-right">
            <button id="node-start-button" class="control-icon-button start" title="Start Node.js Service">â–¶</button>
            <button id="node-stop-button" class="control-icon-button stop" title="Stop Node.js Service">â– </button>
            <button id="node-restart-button" class="control-icon-button restart" title="Restart Node.js Service">â†»</button>
            <div class="status-indicator" id="node-status">
              <span class="status-dot red dimmed" id="node-status-red"></span>
              <span class="status-dot orange dimmed" id="node-status-orange"></span>
              <span class="status-dot green dimmed" id="node-status-green"></span>
            </div>
          </div>
        </div>
        
        <div class="sdk-config">
          <strong>SDK Client Mode:</strong> <span id="node-sdk-mode">Proxy Mode</span>
        </div>
        
        <div class="flag-display">
          <label>Feature Flag: user-message</label>
          <div class="flag-value" id="node-flag-value">Loading...</div>
        </div>
        
        <div class="context-display">
          <h4>Current Context</h4>
          <div id="node-context-info" style="font-size: 13px; line-height: 1.6; color: #555;">
            <div><strong>Type:</strong> <span id="node-context-type">Anonymous</span></div>
            <div><strong>Key:</strong> <span id="node-context-key" style="font-family: monospace; font-size: 11px;">Loading...</span></div>
            <div id="node-context-attributes" style="margin-top: 5px; padding-top: 5px; border-top: 1px solid #eee;">
              <!-- Attributes will be populated here -->
            </div>
          </div>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="node-context-button">Change Context</button>
            <button id="node-test-evaluation" class="btn-secondary">Test Flag Evaluation</button>
          </div>
        </div>
        
        <div class="hash-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="font-size: 13px; color: #333; margin: 0; font-weight: 600;">ðŸ”¢ Bucketing Hash Values</h4>
            <a href="#" id="node-hash-toggle" style="font-size: 12px; color: #405BFF; text-decoration: none; cursor: pointer;">Show</a>
          </div>
          <div id="node-hash-content" style="display: none;">
            <div id="node-hash-info" style="font-size: 12px; line-height: 1.8; color: #555; font-family: 'Courier New', monospace; padding: 12px; background-color: #f8f9fa; border-radius: 4px; border-left: 3px solid #405BFF;">
              <div style="color: #999; font-style: italic;">Waiting for flag evaluation...</div>
            </div>
          </div>
        </div>
        
        <div class="sdk-cache-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <h4 style="font-size: 14px; color: #333; margin-bottom: 10px;">SDK Data Store</h4>
          <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
            Raw flag configurations cached by the SDK (context-independent)
          </div>
          <div id="node-sdk-cache" style="font-size: 12px; line-height: 1.6; color: #555; max-height: 280px; overflow-y: auto; background-color: #f8f9fa; padding: 10px; border-radius: 4px; transition: max-height 0.3s ease;">
            <div style="color: #999; font-style: italic;">Waiting for SDK to initialize...</div>
          </div>
        </div>
      `;
      
      // Set up hash toggle functionality
      const hashToggle = document.getElementById('node-hash-toggle');
      const hashContent = document.getElementById('node-hash-content');
      const sdkCache = document.getElementById('node-sdk-cache');
      if (hashToggle && hashContent) {
        hashToggle.addEventListener('click', (e) => {
          e.preventDefault();
          const isVisible = hashContent.style.display !== 'none';
          hashContent.style.display = isVisible ? 'none' : 'block';
          hashToggle.textContent = isVisible ? 'Show' : 'Hide';
          
          // Adjust SDK cache height when hash section is toggled
          if (sdkCache) {
            if (!isVisible) {
              // Hash section is being shown - shrink SDK cache
              sdkCache.style.maxHeight = '150px';
            } else {
              // Hash section is being hidden - restore SDK cache height
              sdkCache.style.maxHeight = '280px';
            }
          }
        });
      }
      
      // Initialize Node.js panel with ServicePanel
      // Don't call nodePanel.initialize() - it doesn't exist and would reinitialize all panels
      // Just start the specific panel's polling and stream
      nodePanel.startStatusPolling();
      nodePanel.connectStream();
    }
    
    // Initialize Python service panel
    // Requirements: 2.6, 4.3, 4.5
    async function initializePythonPanel() {
      const panel = document.getElementById('node-service-panel');
      if (!panel) {
        console.error('Panel 1 not found');
        return;
      }
      
      // Replace panel content with Python service
      panel.innerHTML = `
        <div class="service-header">
          <div class="service-header-left">
            <img src="python-logo-generic.svg" alt="Python" class="service-logo" />
            <h2>Python Service</h2>
          </div>
          <div class="service-header-right">
            <button id="python-start-button" class="control-icon-button start" title="Start Python Service">â–¶</button>
            <button id="python-stop-button" class="control-icon-button stop" title="Stop Python Service">â– </button>
            <button id="python-restart-button" class="control-icon-button restart" title="Restart Python Service">â†»</button>
            <div class="status-indicator" id="python-status">
              <span class="status-dot red dimmed" id="python-status-red"></span>
              <span class="status-dot orange dimmed" id="python-status-orange"></span>
              <span class="status-dot green dimmed" id="python-status-green"></span>
            </div>
          </div>
        </div>
        
        <div class="sdk-config">
          <strong>SDK Client Mode:</strong> <span id="python-sdk-mode">Default (Direct Connection)</span>
        </div>
        
        <div class="flag-display">
          <label>Feature Flag: user-message</label>
          <div class="flag-value" id="python-flag-value">Loading...</div>
        </div>
        
        <div class="context-display">
          <h4>Current Context</h4>
          <div id="python-context-info" style="font-size: 13px; line-height: 1.6; color: #555;">
            <div><strong>Type:</strong> <span id="python-context-type">Anonymous</span></div>
            <div><strong>Key:</strong> <span id="python-context-key" style="font-family: monospace; font-size: 11px;">Loading...</span></div>
            <div id="python-context-attributes" style="margin-top: 5px; padding-top: 5px; border-top: 1px solid #eee;">
              <!-- Attributes will be populated here -->
            </div>
          </div>
          <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="python-context-button">Change Context</button>
            <button id="python-test-evaluation" class="btn-secondary">Test Flag Evaluation</button>
          </div>
        </div>
        
        <div class="hash-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <h4 style="font-size: 13px; color: #333; margin: 0; font-weight: 600;">ðŸ”¢ Bucketing Hash Values</h4>
            <a href="#" id="python-hash-toggle" style="font-size: 12px; color: #405BFF; text-decoration: none; cursor: pointer;">Show</a>
          </div>
          <div id="python-hash-content" style="display: none;">
            <div id="python-hash-info" style="font-size: 12px; line-height: 1.8; color: #555; font-family: 'Courier New', monospace; padding: 12px; background-color: #f8f9fa; border-radius: 4px; border-left: 3px solid #405BFF;">
              <div style="color: #999; font-style: italic;">Waiting for flag evaluation...</div>
            </div>
          </div>
        </div>
        
        <div class="sdk-cache-display" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #eee;">
          <h4 style="font-size: 14px; color: #333; margin-bottom: 10px;">SDK Data Store</h4>
          <div style="font-size: 12px; color: #666; margin-bottom: 8px;">
            Raw flag configurations cached by the SDK (context-independent)
          </div>
          <div id="python-sdk-cache" style="font-size: 12px; line-height: 1.6; color: #555; max-height: 280px; overflow-y: auto; background-color: #f8f9fa; padding: 10px; border-radius: 4px;">
            <div style="color: #999; font-style: italic;">Loading...</div>
          </div>
        </div>
      `;
      
      // Set up hash toggle functionality
      const hashToggle = document.getElementById('python-hash-toggle');
      const hashContent = document.getElementById('python-hash-content');
      const sdkCache = document.getElementById('python-sdk-cache');
      if (hashToggle && hashContent) {
        hashToggle.addEventListener('click', (e) => {
          e.preventDefault();
          if (hashContent.style.display === 'none') {
            hashContent.style.display = 'block';
            hashToggle.textContent = 'Hide';
            // Shrink SDK cache to make room for hash section
            if (sdkCache) {
              sdkCache.style.maxHeight = '150px';
            }
          } else {
            hashContent.style.display = 'none';
            hashToggle.textContent = 'Show';
            // Restore SDK cache height
            if (sdkCache) {
              sdkCache.style.maxHeight = '280px';
            }
          }
        });
      }
      
      // Fetch Python service data (non-blocking - don't await)
      fetchPythonStatus();
      fetchPythonFlagValue();
      fetchPythonSDKData();
      
      // NOTE: Do NOT call connectPythonSSE() here - the ServicePanel handles SSE connections
      // via pythonPanel.reconnectStream() which is called after context is loaded
      
      // Set up Python control button handlers
      const pythonStartButton = document.getElementById('python-start-button');
      const pythonStopButton = document.getElementById('python-stop-button');
      const pythonRestartButton = document.getElementById('python-restart-button');
      
      if (pythonStartButton) {
        pythonStartButton.addEventListener('click', async () => {
          try {
            pythonStartButton.disabled = true;
            const response = await fetch('http://localhost:4000/api/python/start', {
              method: 'POST'
            });
            const data = await response.json();
            console.log('Python container start:', data);
            // Refresh status immediately (will re-enable button)
            setTimeout(async () => {
              await pollPythonContainerStatus();
            }, 2000);
          } catch (error) {
            console.error('Error starting Python container:', error);
            pythonStartButton.disabled = false;
          }
        });
      }
      
      if (pythonStopButton) {
        pythonStopButton.addEventListener('click', async () => {
          try {
            pythonStopButton.disabled = true;
            const response = await fetch('http://localhost:4000/api/python/stop', {
              method: 'POST'
            });
            const data = await response.json();
            console.log('Python container stop:', data);
            // Refresh status immediately (will re-enable button)
            setTimeout(async () => {
              await pollPythonContainerStatus();
            }, 2000);
          } catch (error) {
            console.error('Error stopping Python container:', error);
            pythonStopButton.disabled = false;
          }
        });
      }
      
      if (pythonRestartButton) {
        pythonRestartButton.addEventListener('click', async () => {
          try {
            pythonRestartButton.disabled = true;
            const response = await fetch('http://localhost:4000/api/python/restart', {
              method: 'POST'
            });
            const data = await response.json();
            console.log('Python container restart:', data);
            // Refresh status immediately (will re-enable button)
            setTimeout(async () => {
              await pollPythonContainerStatus();
            }, 3000);
          } catch (error) {
            console.error('Error restarting Python container:', error);
            pythonRestartButton.disabled = false;
          }
        });
      }
      
      // Set up Python context button handler
      // REMOVED: This is handled in main initialization code now
      // The Python panel is pre-loaded in HTML, event listener attached there
      
      // Set up Python test evaluation button handler
      // REMOVED: This is handled in main initialization code now
      
    }
    
    // Fetch Python service status
    // Requirements: 4.5
    async function fetchPythonStatus() {
      try {
        // Check container status
        const containerResponse = await fetch('http://localhost:4000/api/python/container-status');
        const startButton = document.getElementById('python-start-button');
        const stopButton = document.getElementById('python-stop-button');
        const restartButton = document.getElementById('python-restart-button');
        
        if (containerResponse.ok) {
          const containerData = await containerResponse.json();
          
          if (containerData.status === 'running') {
            updatePillStatus('python', 'connected');
            if (startButton) startButton.style.display = 'none';
            if (stopButton) stopButton.style.display = 'flex';
            if (restartButton) restartButton.style.display = 'flex';
          } else if (containerData.status === 'exited' || containerData.status === 'stopped') {
            updatePillStatus('python', 'disconnected');
            if (startButton) startButton.style.display = 'flex';
            if (stopButton) stopButton.style.display = 'none';
            if (restartButton) restartButton.style.display = 'none';
          } else {
            updatePillStatus('python', 'starting');
            if (startButton) startButton.style.display = 'none';
            if (stopButton) stopButton.style.display = 'none';
            if (restartButton) restartButton.style.display = 'none';
          }
        } else {
          // Fallback to SDK status check
          const response = await fetch('http://localhost:4000/api/python/status');
          const data = await response.json();
          
          if (data.connected) {
            updatePillStatus('python', 'connected');
            if (startButton) startButton.style.display = 'none';
            if (stopButton) stopButton.style.display = 'flex';
            if (restartButton) restartButton.style.display = 'flex';
          } else {
            updatePillStatus('python', 'disconnected');
            if (startButton) startButton.style.display = 'flex';
            if (stopButton) stopButton.style.display = 'none';
            if (restartButton) restartButton.style.display = 'none';
          }
        }
      } catch (error) {
        console.error('Error fetching Python status:', error);
        updatePillStatus('python', 'disconnected');
        const startButton = document.getElementById('python-start-button');
        const stopButton = document.getElementById('python-stop-button');
        const restartButton = document.getElementById('python-restart-button');
        if (startButton) startButton.style.display = 'flex';
        if (stopButton) stopButton.style.display = 'none';
        if (restartButton) restartButton.style.display = 'none';
      }
    }
    
    // Fetch Python flag value
    // Requirements: 4.5
    async function fetchPythonFlagValue() {
      try {
        // Don't pass contextKey - let the server use current_context
        const response = await fetch('http://localhost:5000/api/flag');
        const data = await response.json();
        
        const flagValueElement = document.getElementById('python-flag-value');
        if (flagValueElement && data.value) {
          flagValueElement.textContent = data.value;
        }
        
        // Context display is now handled by ServicePanel.updateContextDisplay()
        // No need to update it here to avoid race conditions
        
        // Update hash info if available
        if (data.hashInfo) {
          const hashInfoElement = document.getElementById('python-hash-info');
          if (hashInfoElement) {
            hashInfoElement.innerHTML = `
              <div><strong>Hash Value:</strong> ${data.hashInfo.hashValue}</div>
              <div><strong>Bucket Value:</strong> ${data.hashInfo.bucketValue}</div>
              <div><strong>Salt:</strong> ${data.hashInfo.salt}</div>
            `;
          }
        }
      } catch (error) {
        console.error('Error fetching Python flag value:', error);
        const flagValueElement = document.getElementById('python-flag-value');
        if (flagValueElement) {
          flagValueElement.textContent = 'Error loading flag';
          flagValueElement.style.color = '#f44336';
        }
      }
    }
    
    // Fetch Python SDK data store
    // Requirements: 4.5
    async function fetchPythonSDKData() {
      const cacheElement = document.getElementById('python-sdk-cache');
      if (!cacheElement) {
        console.error('[fetchPythonSDKData] Cache element not found');
        return;
      }
      
      // Show loading state
      cacheElement.innerHTML = '<div style="color: #999; font-style: italic;">Loading SDK data...</div>';
      
      try {
        console.log('[fetchPythonSDKData] Fetching from http://localhost:4000/api/python/sdk-data-store');
        const response = await fetch('http://localhost:4000/api/python/sdk-data-store', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({})
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('[fetchPythonSDKData] Received data:', data);
        
        if (data.flags) {
          const flags = data.flags;
          const flagKeys = Object.keys(flags);
          
          console.log('[fetchPythonSDKData] Processing', flagKeys.length, 'flags');
          
          let html = '';
          if (flagKeys.length === 0) {
            html = '<div style="color: #999; font-style: italic;">No flags in SDK data store</div>';
          } else {
            html = '<div style="font-family: monospace;">';
            flagKeys.forEach(key => {
              const flag = flags[key];
              console.log('[fetchPythonSDKData] Processing flag:', key, flag);
              
              html += `<div style="margin-bottom: 12px; padding: 8px; background-color: white; border-radius: 3px; border: 1px solid #e0e0e0;">`;
              html += `<div style="margin-bottom: 4px;"><strong style="color: #405BFF;">${escapeHtml(key)}</strong></div>`;
              html += `<div style="font-size: 11px; color: #666; line-height: 1.8;">`;
              
              // Display the evaluated value and metadata
              if (flag.value !== undefined) {
                const displayValue = typeof flag.value === 'object' ? JSON.stringify(flag.value) : String(flag.value);
                html += `<div>Value: <span style="color: #333; font-weight: 500;">${escapeHtml(displayValue)}</span></div>`;
              }
              
              if (flag.version !== undefined) {
                html += `<div>Version: <span style="color: #333;">${flag.version}</span></div>`;
              }
              
              if (flag.variation !== undefined) {
                html += `<div>Variation Index: <span style="color: #333;">${flag.variation}</span></div>`;
              }
              
              if (flag.reason && flag.reason.kind) {
                html += `<div>Reason: <span style="color: #333;">${flag.reason.kind}</span></div>`;
              }
              
              html += `<div style="font-size: 10px; color: #999; margin-top: 4px;">Default mode: showing evaluated values from SDK cache</div>`;
              html += `</div>`;
              html += `</div>`;
            });
            html += '</div>';
          }
          
          console.log('[fetchPythonSDKData] Setting innerHTML, length:', html.length);
          cacheElement.innerHTML = html;
          console.log('[fetchPythonSDKData] Render complete');
        } else {
          console.warn('[fetchPythonSDKData] No flags property in response');
          cacheElement.innerHTML = '<div style="color: #999; font-style: italic;">No flag data available</div>';
        }
      } catch (error) {
        console.error('[fetchPythonSDKData] Error:', error);
        cacheElement.innerHTML = `<div style="color: #f44336;">Error: ${error.message}</div>`;
      }
    }
    
    // DEPRECATED: This function is no longer used - ServicePanel handles SSE connections
    // Connect to Python SSE endpoint for real-time flag updates
    // Requirements: 4.4
    function connectPythonSSE_DEPRECATED() {
      // This function is deprecated - Python now uses ServicePanel.connectStream()
      console.warn('[DEPRECATED] connectPythonSSE() should not be called - use pythonPanel.connectStream() instead');
    }
    
    // Update Python hash information display
    function updatePythonHashInfo(hashInfo, contextKey) {
      const hashElement = document.getElementById('python-hash-info');
      if (hashElement && hashInfo) {
        let html = '';
        html += `<div style="margin-bottom: 4px;"><strong>Context Key:</strong> ${escapeHtml(contextKey || 'unknown')}</div>`;
        html += `<div style="margin-bottom: 4px;"><strong>Salt:</strong> ${escapeHtml(hashInfo.salt || 'N/A')}</div>`;
        html += `<div style="margin-bottom: 4px;"><strong>Hash Value:</strong> <span style="color: #405BFF;">${hashInfo.hashValue}</span></div>`;
        html += `<div><strong>Bucket Value:</strong> <span style="color: #4caf50; font-weight: 600;">${hashInfo.bucketValue.toFixed(5)}</span></div>`;
        html += `<div style="margin-top: 6px; font-size: 11px; color: #666; font-style: italic;">Bucket determines which variation the user receives in percentage rollouts</div>`;
        hashElement.innerHTML = html;
      }
    }
    
    document.addEventListener('DOMContentLoaded', async () => {
      // Initialize LaunchDarkly JavaScript SDK FIRST before rendering anything
      console.log('[Dashboard] Initializing LaunchDarkly JavaScript SDK...');
      
      // Get client-side ID from meta tag (injected by server)
      const clientSideId = document.querySelector('meta[name="ld-client-id"]')?.content;
      
      let showTerminalPanels = true; // Default to showing panels
      
      if (!clientSideId) {
        console.error('[Dashboard] LaunchDarkly client-side ID not found. Terminal panels will remain visible.');
      } else if (sdkInitialized) {
        console.warn('[Dashboard] SDK already initialized, skipping re-initialization');
      } else {
        sdkInitialized = true;
        try {
          // Initialize the SDK - connects directly to LaunchDarkly (not through Relay Proxy)
          // Client-side SDKs are designed to connect to LaunchDarkly's CDN
          // Using a static "container" context for the dashboard
          const ldClient = window.LDClient.initialize(clientSideId, {
            kind: 'container',
            key: 'dashboard-v2'
          }, {
            // Explicitly configure SDK behavior to prevent reloads
            bootstrap: 'localStorage',  // Use localStorage to cache flags
            streaming: true,             // Enable streaming for real-time updates
            sendEvents: false,           // Disable analytics events
            allAttributesPrivate: true,  // Privacy setting
            flushInterval: 30000,        // Reduce flush frequency
            diagnosticOptOut: true,      // Disable diagnostic events
            useReport: false,            // Don't use REPORT method
            evaluationReasons: false     // Don't fetch reasons
          });
          
          // Wait for SDK to be ready
          await ldClient.waitForInitialization();
          console.log('[Dashboard] LaunchDarkly JavaScript SDK initialized');
          
          // Get initial flag value BEFORE rendering
          showTerminalPanels = ldClient.variation('terminal-panels', true);
          console.log('[Dashboard] terminal-panels flag value:', showTerminalPanels);
          
          // Apply initial state BEFORE any rendering
          const dashboardContainer = document.querySelector('.dashboard-container');
          const logsSection = document.querySelector('.logs-section');
          
          if (!showTerminalPanels) {
            console.log('[Dashboard] Hiding terminal panels (initial state)');
            dashboardContainer.classList.add('hide-logs');
            logsSection.classList.add('hidden');
          } else {
            console.log('[Dashboard] Showing terminal panels (initial state)');
            dashboardContainer.classList.remove('hide-logs');
            logsSection.classList.remove('hidden');
          }
          
          // Listen for flag changes
          ldClient.on('change:terminal-panels', (newValue) => {
            console.log('[Dashboard] terminal-panels flag changed to:', newValue);
            
            if (!newValue) {
              console.log('[Dashboard] Hiding terminal panels');
              dashboardContainer.classList.add('hide-logs');
              logsSection.classList.add('hidden');
            } else {
              console.log('[Dashboard] Showing terminal panels');
              dashboardContainer.classList.remove('hide-logs');
              logsSection.classList.remove('hidden');
            }
          });
          
          // Listen for panel service changes using BOOLEAN flag
          // Flag: dashboard-service-panel-1 (boolean)
          // - true = show Python panel
          // - false = show Node.js panel
          // Note: This flag causes page reload when toggled from LaunchDarkly UI (known SDK behavior)
          ldClient.on('change:dashboard-service-panel-1', (showPython) => {
            console.log('[Dashboard] ===== FLAG CHANGE DETECTED =====');
            console.log('[Dashboard] dashboard-service-panel-1 changed to:', showPython);
            
            // Determine which service to show
            const newService = showPython ? 'python' : 'node';
            const oldService = window.currentPanelService;
            
            if (newService === oldService) {
              console.log('[Dashboard] Panel service unchanged, no action needed');
              return;
            }
            
            console.log(`[Dashboard] Switching Panel 1 from ${oldService} to ${newService}`);
            
            // Update the global service tracker
            window.currentPanelService = newService;
            
            // Get both panels
            const nodePanelEl = document.getElementById('node-service-panel');
            const pythonPanelEl = document.getElementById('python-service-panel');
            
            if (!nodePanelEl || !pythonPanelEl) {
              console.error('[Dashboard] Panel elements not found');
              return;
            }
            
            // Switch panels with CSS classes
            if (showPython) {
              console.log('[Dashboard] Showing Python panel');
              nodePanelEl.classList.remove('active');
              pythonPanelEl.classList.add('active');
              
              // Connect Python SSE stream if not already connected
              if (pythonPanel && !pythonPanel.eventSource) {
                console.log('[Dashboard] Connecting Python SSE stream');
                setTimeout(() => {
                  pythonPanel.connectStream();
                }, 200);
              }
            } else {
              console.log('[Dashboard] Showing Node panel');
              pythonPanelEl.classList.remove('active');
              nodePanelEl.classList.add('active');
              
              // Disconnect Python SSE stream to save resources
              if (pythonPanel && pythonPanel.eventSource) {
                console.log('[Dashboard] Disconnecting Python SSE stream');
                pythonPanel.eventSource.close();
                pythonPanel.eventSource = null;
              }
            }
            
            // Update terminal panel labels
            updateTerminalPanel1(newService);
            
            // Reinitialize Panel 1 log console to connect to the correct service
            if (window.initializePanel1LogConsole) {
              console.log('[Dashboard] Reinitializing Panel 1 log console for service change');
              window.initializePanel1LogConsole();
            }
            
            console.log('[Dashboard] ===== FLAG CHANGE COMPLETE =====');
          });
          
        } catch (error) {
          console.error('[Dashboard] Failed to initialize LaunchDarkly SDK:', error);
          console.log('[Dashboard] Terminal panels will remain visible');
        }
      }
      
      // NOW create service panel instances
      console.log('[Dashboard] Creating service panels...');
      nodePanel = new ServicePanel('node', 'http://localhost:3000/api/node');
      console.log('[Dashboard] Node panel created');
      phpPanel = new ServicePanel('php', 'http://localhost:4000/api/php');
      console.log('[Dashboard] PHP panel created');
      pythonPanel = new ServicePanel('python', 'http://localhost:4000/api/python');
      console.log('[Dashboard] Python panel created');
      
      // Fetch panel configuration and initialize Panel 1 dynamically
      console.log('[Dashboard] Fetching panel configuration...');
      const panelService = await fetchPanelConfiguration();
      console.log('[Dashboard] Panel 1 will display:', panelService);
      
      // Store panel service for later use (terminal panel initialization)
      window.currentPanelService = panelService;
      
      // Initialize Panel 1 based on feature flag - just set the active class
      const nodePanelEl = document.getElementById('node-service-panel');
      const pythonPanelEl = document.getElementById('python-service-panel');
      
      if (panelService === 'python') {
        console.log('[Dashboard] Initializing Python service in Panel 1');
        nodePanelEl.classList.remove('active');
        pythonPanelEl.classList.add('active');
        updateTerminalPanel1('python');
      } else {
        console.log('[Dashboard] Initializing Node.js service in Panel 1 (default)');
        nodePanelEl.classList.add('active');
        pythonPanelEl.classList.remove('active');
        updateTerminalPanel1('node');
      }
      
      // Note: Panel 1 log console will be initialized later after the function is defined
      
      // Update relay proxy status by fetching via backend proxy (CORS workaround)
      async function updateRelayProxyStatus() {
        try {
          const response = await fetch('http://localhost:4000/api/relay-status');
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          
          const data = await response.json();
          
          const statusIndicator = document.getElementById('relay-proxy-status');
          const statusText = document.getElementById('relay-proxy-status-text');
          const startButton = document.getElementById('relay-proxy-start-button');
          const stopButton = document.getElementById('relay-proxy-stop-button');
          const restartButton = document.getElementById('relay-proxy-restart-button');
          
          // Check if Redis is available
          if (data.redisAvailable === false) {
            // Redis is down - show degraded status
            updatePillStatus('relay-proxy', 'degraded');
            statusText.textContent = `Degraded - Redis Unavailable${data.version ? ' - v' + data.version : ''}`;
            statusText.style.color = '#ff9800';
            
            // Show stop and restart buttons (Relay Proxy is running but degraded)
            if (startButton) startButton.style.display = 'none';
            if (stopButton) stopButton.style.display = 'flex';
            if (restartButton) restartButton.style.display = 'flex';
          } else if (data.status === 'degraded') {
            // Other degraded state
            updatePillStatus('relay-proxy', 'degraded');
            statusText.textContent = `Degraded${data.version ? ' - v' + data.version : ''}`;
            statusText.style.color = '#ff9800';
            
            // Show stop and restart buttons
            if (startButton) startButton.style.display = 'none';
            if (stopButton) stopButton.style.display = 'flex';
            if (restartButton) restartButton.style.display = 'flex';
          } else {
            // Healthy
            updatePillStatus('relay-proxy', 'connected');
            statusText.textContent = `Connected${data.version ? ' - v' + data.version : ''}`;
            statusText.style.color = '#4caf50';
            
            // Show stop and restart buttons
            if (startButton) startButton.style.display = 'none';
            if (stopButton) stopButton.style.display = 'flex';
            if (restartButton) restartButton.style.display = 'flex';
            
            // Connect to Relay Proxy cache SSE stream when connected
            if (!relayProxyCacheEventSource || relayProxyCacheEventSource.readyState === EventSource.CLOSED) {
              connectRelayProxyCacheStream();
            }
          }
          
        } catch (error) {
          const statusIndicator = document.getElementById('relay-proxy-status');
          const statusText = document.getElementById('relay-proxy-status-text');
          const startButton = document.getElementById('relay-proxy-start-button');
          const stopButton = document.getElementById('relay-proxy-stop-button');
          const restartButton = document.getElementById('relay-proxy-restart-button');
          
          updatePillStatus('relay-proxy', 'disconnected');
          statusText.textContent = 'Disconnected';
          statusText.style.color = '#f44336';
          
          // Show start button, hide stop and restart when disconnected
          if (startButton) startButton.style.display = 'flex';
          if (stopButton) stopButton.style.display = 'none';
          if (restartButton) restartButton.style.display = 'none';
        }
      }
      
      // Poll Redis status
      // Fetch and display Redis data store
      async function fetchRedisDataStore() {
        const dataStoreElement = document.getElementById('redis-data-store');
        
        if (!dataStoreElement) {
          console.error('Redis data store element not found');
          return;
        }
        
        // Show loading state
        dataStoreElement.innerHTML = '<div style="color: #999; font-style: italic;">Loading...</div>';
        
        try {
          const response = await fetch('http://localhost:4000/api/redis/data-store', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          });
          
          const data = await response.json();
          
          if (!response.ok || !data.success) {
            const errorMsg = data.error || `HTTP ${response.status}`;
            dataStoreElement.innerHTML = `<div style="color: #f44336;">Error: ${errorMsg}</div>`;
            return;
          }
          
          if (data.flags) {
            const flags = data.flags;
            const flagKeys = Object.keys(flags);
            
            let html = '';
            
            if (flagKeys.length === 0) {
              html += '<div style="color: #999; font-style: italic;">No flags in Redis</div>';
            } else {
              html += '<div style="font-family: monospace;">';
              flagKeys.forEach(key => {
                const flagValue = flags[key];
                
                const isComplexConfig = flagValue && typeof flagValue === 'object' && flagValue.version !== undefined;
                
                html += `<div style="margin-bottom: 12px; padding: 8px; background-color: white; border-radius: 3px; border: 1px solid #e0e0e0;">`;
                html += `<div style="margin-bottom: 4px;"><strong style="color: #405BFF;">${escapeHtml(key)}</strong></div>`;
                
                if (isComplexConfig) {
                  html += `<div style="font-size: 11px; color: #666; line-height: 1.8;">`;
                  html += `<div>Version: <span style="color: #333;">${flagValue.version || 'N/A'}</span></div>`;
                  html += `<div>Enabled: <span style="color: #333;">${flagValue.on ? 'Yes' : 'No'}</span></div>`;
                  
                  if (flagValue.variations && flagValue.variations.length > 0) {
                    html += `<div style="margin-top: 6px;"><strong>Variations (${flagValue.variations.length}):</strong></div>`;
                    flagValue.variations.forEach((variation, index) => {
                      const varValue = typeof variation === 'object' ? JSON.stringify(variation) : variation;
                      html += `<div style="margin-left: 12px; font-size: 10px;">`;
                      html += `[${index}]: <span style="color: #405BFF; font-weight: 500;">${escapeHtml(varValue)}</span>`;
                      html += `</div>`;
                    });
                  }
                  
                  if (flagValue.fallthrough) {
                    if (flagValue.fallthrough.variation !== undefined) {
                      html += `<div style="margin-top: 6px;">Default (fallthrough): <span style="color: #333;">variation ${flagValue.fallthrough.variation}</span></div>`;
                    } else if (flagValue.fallthrough.rollout) {
                      html += `<div style="margin-top: 6px;"><strong>Default (rollout):</strong></div>`;
                      const rollout = flagValue.fallthrough.rollout;
                      if (rollout.variations) {
                        rollout.variations.forEach((rv) => {
                          const percentage = (rv.weight / 1000).toFixed(1);
                          html += `<div style="margin-left: 12px; font-size: 10px;">`;
                          html += `Variation ${rv.variation}: ${percentage}%`;
                          html += `</div>`;
                        });
                      }
                    }
                  }
                  
                  if (flagValue.offVariation !== undefined) {
                    html += `<div>Off variation: <span style="color: #333;">variation ${flagValue.offVariation}</span></div>`;
                  }
                  
                  if (flagValue.rules && flagValue.rules.length > 0) {
                    html += `<div style="margin-top: 6px;"><strong>Rules (${flagValue.rules.length}):</strong></div>`;
                    flagValue.rules.forEach((rule, index) => {
                      html += `<div style="margin-left: 12px; font-size: 10px; margin-bottom: 4px;">`;
                      html += `<strong>Rule ${index + 1}:</strong>`;
                      
                      if (rule.variation !== undefined) {
                        html += ` â†’ Variation ${rule.variation}`;
                      } else if (rule.rollout) {
                        html += ` â†’ Rollout`;
                      }
                      
                      if (rule.clauses && rule.clauses.length > 0) {
                        html += `<div style="margin-left: 12px; margin-top: 2px;">`;
                        rule.clauses.forEach((clause) => {
                          const negateText = clause.negate ? 'NOT ' : '';
                          const attribute = clause.attribute || 'key';
                          const op = clause.op || 'unknown';
                          const values = clause.values || [];
                          
                          html += `<div style="color: #666;">`;
                          html += `${negateText}${attribute} ${op} `;
                          
                          if (values.length === 1) {
                            html += `"${escapeHtml(values[0])}"`;
                          } else if (values.length > 1) {
                            html += `[${values.map(v => `"${escapeHtml(v)}"`).join(', ')}]`;
                          }
                          
                          html += `</div>`;
                        });
                        html += `</div>`;
                      }
                      
                      html += `</div>`;
                    });
                  }
                  
                  if (flagValue.targets && flagValue.targets.length > 0) {
                    html += `<div style="margin-top: 6px;"><strong>Targets (${flagValue.targets.length}):</strong></div>`;
                    flagValue.targets.forEach((target) => {
                      const userCount = target.values ? target.values.length : 0;
                      html += `<div style="margin-left: 12px; font-size: 10px;">`;
                      html += `Variation ${target.variation}: ${userCount} user(s)`;
                      if (target.values && target.values.length > 0 && target.values.length <= 5) {
                        html += ` - ${target.values.map(v => escapeHtml(v)).join(', ')}`;
                      } else if (target.values && target.values.length > 5) {
                        html += ` - ${target.values.slice(0, 5).map(v => escapeHtml(v)).join(', ')}, ...`;
                      }
                      html += `</div>`;
                    });
                  }
                  
                  if (flagValue.prerequisites && flagValue.prerequisites.length > 0) {
                    html += `<div style="margin-top: 6px;"><strong>Prerequisites (${flagValue.prerequisites.length}):</strong></div>`;
                    flagValue.prerequisites.forEach((prereq) => {
                      html += `<div style="margin-left: 12px; font-size: 10px;">`;
                      html += `${escapeHtml(prereq.key)} must be variation ${prereq.variation}`;
                      html += `</div>`;
                    });
                  }
                  
                  html += `</div>`;
                } else {
                  html += `<div style="font-size: 11px; color: #666; line-height: 1.8;">`;
                  html += `<div>Value: <span style="color: #333; font-weight: 500;">${escapeHtml(JSON.stringify(flagValue))}</span></div>`;
                  html += `</div>`;
                }
                
                html += `</div>`;
              });
              html += '</div>';
            }
            
            dataStoreElement.innerHTML = html;
          } else {
            dataStoreElement.innerHTML = '<div style="color: #999; font-style: italic;">No flags found</div>';
          }
        } catch (error) {
          console.error('Error fetching Redis data store:', error);
          dataStoreElement.innerHTML = `<div style="color: #f44336;">Error: ${error.message}</div>`;
        }
      }
      
      // Render Relay Proxy cache display from flag data
      function renderRelayProxyCache(flags) {
        console.log('[renderRelayProxyCache] Called with', Object.keys(flags).length, 'flags');
        const cacheElement = document.getElementById('relay-proxy-cache');
        
        if (!cacheElement) {
          console.error('Relay Proxy cache element not found');
          return;
        }
        
        const flagKeys = Object.keys(flags);
        let html = '';
        
        // Add timestamp to verify updates
        html += `<div style="font-size: 10px; color: #999; margin-bottom: 8px;">Last updated: ${new Date().toLocaleTimeString()}</div>`;
        
        if (flagKeys.length === 0) {
          html += '<div style="color: #999; font-style: italic;">No flags in Relay Proxy cache</div>';
        } else {
          html += '<div style="font-family: monospace;">';
          flagKeys.forEach(key => {
            const flagValue = flags[key];
            
            const isComplexConfig = flagValue && typeof flagValue === 'object' && flagValue.version !== undefined;
            
            html += `<div style="margin-bottom: 12px; padding: 8px; background-color: white; border-radius: 3px; border: 1px solid #e0e0e0;">`;
            html += `<div style="margin-bottom: 4px;"><strong style="color: #405BFF;">${escapeHtml(key)}</strong></div>`;
            
            if (isComplexConfig) {
              html += `<div style="font-size: 11px; color: #666; line-height: 1.8;">`;
              html += `<div>Version: <span style="color: #333;">${flagValue.version || 'N/A'}</span></div>`;
              html += `<div>Enabled: <span style="color: #333;">${flagValue.on ? 'Yes' : 'No'}</span></div>`;
              
              if (flagValue.variations && flagValue.variations.length > 0) {
                html += `<div style="margin-top: 6px;"><strong>Variations (${flagValue.variations.length}):</strong></div>`;
                flagValue.variations.forEach((variation, index) => {
                  const varValue = typeof variation === 'object' ? JSON.stringify(variation) : variation;
                  html += `<div style="margin-left: 12px; font-size: 10px;">`;
                  html += `[${index}]: <span style="color: #405BFF; font-weight: 500;">${escapeHtml(varValue)}</span>`;
                  html += `</div>`;
                });
              }
              
              if (flagValue.fallthrough) {
                if (flagValue.fallthrough.variation !== undefined) {
                  html += `<div style="margin-top: 6px;">Default (fallthrough): <span style="color: #333;">variation ${flagValue.fallthrough.variation}</span></div>`;
                } else if (flagValue.fallthrough.rollout) {
                  html += `<div style="margin-top: 6px;"><strong>Default (rollout):</strong></div>`;
                  const rollout = flagValue.fallthrough.rollout;
                  if (rollout.variations) {
                    rollout.variations.forEach((rv) => {
                      const percentage = (rv.weight / 1000).toFixed(1);
                      html += `<div style="margin-left: 12px; font-size: 10px;">`;
                      html += `Variation ${rv.variation}: ${percentage}%`;
                      html += `</div>`;
                    });
                  }
                }
              }
              
              if (flagValue.offVariation !== undefined) {
                html += `<div>Off variation: <span style="color: #333;">variation ${flagValue.offVariation}</span></div>`;
              }
              
              if (flagValue.rules && flagValue.rules.length > 0) {
                html += `<div style="margin-top: 6px;"><strong>Rules (${flagValue.rules.length}):</strong></div>`;
                flagValue.rules.forEach((rule, index) => {
                  html += `<div style="margin-left: 12px; font-size: 10px; margin-bottom: 4px;">`;
                  html += `<strong>Rule ${index + 1}:</strong>`;
                  
                  if (rule.variation !== undefined) {
                    html += ` â†’ Variation ${rule.variation}`;
                  } else if (rule.rollout) {
                    html += ` â†’ Rollout`;
                  }
                  
                  if (rule.clauses && rule.clauses.length > 0) {
                    html += `<div style="margin-left: 12px; margin-top: 2px;">`;
                    rule.clauses.forEach((clause) => {
                      const negateText = clause.negate ? 'NOT ' : '';
                      const attribute = clause.attribute || 'key';
                      const op = clause.op || 'unknown';
                      const values = clause.values || [];
                      
                      html += `<div style="color: #666;">`;
                      html += `${negateText}${attribute} ${op} `;
                      
                      if (values.length === 1) {
                        html += `"${escapeHtml(values[0])}"`;
                      } else if (values.length > 1) {
                        html += `[${values.map(v => `"${escapeHtml(v)}"`).join(', ')}]`;
                      }
                      
                      html += `</div>`;
                    });
                    html += `</div>`;
                  }
                  
                  html += `</div>`;
                });
              }
              
              if (flagValue.targets && flagValue.targets.length > 0) {
                html += `<div style="margin-top: 6px;"><strong>Targets (${flagValue.targets.length}):</strong></div>`;
                flagValue.targets.forEach((target) => {
                  const userCount = target.values ? target.values.length : 0;
                  html += `<div style="margin-left: 12px; font-size: 10px;">`;
                  html += `Variation ${target.variation}: ${userCount} user(s)`;
                  if (target.values && target.values.length > 0 && target.values.length <= 5) {
                    html += ` - ${target.values.map(v => escapeHtml(v)).join(', ')}`;
                  } else if (target.values && target.values.length > 5) {
                    html += ` - ${target.values.slice(0, 5).map(v => escapeHtml(v)).join(', ')}, ...`;
                  }
                  html += `</div>`;
                });
              }
              
              if (flagValue.prerequisites && flagValue.prerequisites.length > 0) {
                html += `<div style="margin-top: 6px;"><strong>Prerequisites (${flagValue.prerequisites.length}):</strong></div>`;
                flagValue.prerequisites.forEach((prereq) => {
                  html += `<div style="margin-left: 12px; font-size: 10px;">`;
                  html += `${escapeHtml(prereq.key)} must be variation ${prereq.variation}`;
                  html += `</div>`;
                });
              }
              
              html += `</div>`;
            } else {
              html += `<div style="font-size: 11px; color: #666; line-height: 1.8;">`;
              html += `<div>Value: <span style="color: #333; font-weight: 500;">${escapeHtml(JSON.stringify(flagValue))}</span></div>`;
              html += `</div>`;
            }
            
            html += `</div>`;
          });
          html += '</div>';
        }
        
        cacheElement.innerHTML = html;
        console.log('[renderRelayProxyCache] Render complete');
      }
      
      // Render Node SDK cache (reuses same logic as Relay Proxy)
      function renderNodeSDKCache(flags) {
        console.log('[renderNodeSDKCache] Called with', Object.keys(flags).length, 'flags');
        const cacheElement = document.getElementById('node-sdk-cache');
        if (!cacheElement) return;
        
        const flagKeys = Object.keys(flags);
        let html = '';
        
        // Add timestamp to verify updates
        html += `<div style="font-size: 10px; color: #999; margin-bottom: 8px;">Last updated: ${new Date().toLocaleTimeString()}</div>`;
        
        if (flagKeys.length === 0) {
          html += '<div style="color: #999; font-style: italic;">No flags in Node SDK cache</div>';
        } else {
          html += renderFlagList(flags);
        }
        
        cacheElement.innerHTML = html;
        console.log('[renderNodeSDKCache] Render complete');
      }
      
      // Render Redis data store (reuses same logic as Relay Proxy)
      function renderRedisDataStore(flags) {
        console.log('[renderRedisDataStore] Called with', Object.keys(flags).length, 'flags');
        const dataStoreElement = document.getElementById('redis-data-store');
        if (!dataStoreElement) {
          console.error('[renderRedisDataStore] Element not found!');
          return;
        }
        
        console.log('[renderRedisDataStore] Element found, current innerHTML length:', dataStoreElement.innerHTML.length);
        
        const flagKeys = Object.keys(flags);
        let html = '';
        
        // Add timestamp to verify updates
        html += `<div style="font-size: 10px; color: #999; margin-bottom: 8px;">Last updated: ${new Date().toLocaleTimeString()}</div>`;
        
        if (flagKeys.length === 0) {
          html += '<div style="color: #999; font-style: italic;">No flags in Redis</div>';
        } else {
          html += renderFlagList(flags);
        }
        
        console.log('[renderRedisDataStore] About to set innerHTML, new HTML length:', html.length);
        dataStoreElement.innerHTML = html;
        console.log('[renderRedisDataStore] innerHTML set, new length:', dataStoreElement.innerHTML.length);
        console.log('[renderRedisDataStore] Render complete');
      }
      
      // Make renderRedisDataStore globally accessible for pollRedisStatus()
      window.renderRedisDataStore = renderRedisDataStore;
      
      // Render PHP SDK cache (reuses same logic as Relay Proxy)
      function renderPHPSDKCache(flags) {
        console.log('[renderPHPSDKCache] Called with', Object.keys(flags).length, 'flags');
        const cacheElement = document.getElementById('php-sdk-cache');
        if (!cacheElement) {
          console.error('[renderPHPSDKCache] Element not found!');
          return;
        }
        
        console.log('[renderPHPSDKCache] Element found, current innerHTML length:', cacheElement.innerHTML.length);
        
        const flagKeys = Object.keys(flags);
        let html = '';
        
        // Add timestamp to verify updates
        html += `<div style="font-size: 10px; color: #999; margin-bottom: 8px;">Last updated: ${new Date().toLocaleTimeString()}</div>`;
        
        if (flagKeys.length === 0) {
          html += '<div style="color: #999; font-style: italic;">No flags in PHP SDK cache</div>';
        } else {
          html += renderFlagList(flags);
        }
        
        console.log('[renderPHPSDKCache] About to set innerHTML, new HTML length:', html.length);
        cacheElement.innerHTML = html;
        console.log('[renderPHPSDKCache] innerHTML set, new length:', cacheElement.innerHTML.length);
        console.log('[renderPHPSDKCache] Render complete');
      }
      
      // Make renderPHPSDKCache globally accessible for ServicePanel.fetchPHPCache()
      window.renderPHPSDKCache = renderPHPSDKCache;
      
      // Shared function to render flag list (DRY principle)
      function renderFlagList(flags) {
        const flagKeys = Object.keys(flags);
        let html = '<div style="font-family: monospace;">';
        
        flagKeys.forEach(key => {
          const flagValue = flags[key];
          const isComplexConfig = flagValue && typeof flagValue === 'object' && flagValue.version !== undefined;
          
          html += `<div style="margin-bottom: 12px; padding: 8px; background-color: white; border-radius: 3px; border: 1px solid #e0e0e0;">`;
          html += `<div style="margin-bottom: 4px;"><strong style="color: #405BFF;">${escapeHtml(key)}</strong></div>`;
          
          if (isComplexConfig) {
            html += `<div style="font-size: 11px; color: #666; line-height: 1.8;">`;
            html += `<div>Version: <span style="color: #333;">${flagValue.version || 'N/A'}</span></div>`;
            html += `<div>Enabled: <span style="color: #333;">${flagValue.on ? 'Yes' : 'No'}</span></div>`;
            
            if (flagValue.variations && flagValue.variations.length > 0) {
              html += `<div style="margin-top: 6px;"><strong>Variations (${flagValue.variations.length}):</strong></div>`;
              flagValue.variations.forEach((variation, index) => {
                const varValue = typeof variation === 'object' ? JSON.stringify(variation) : variation;
                html += `<div style="margin-left: 12px; font-size: 10px;">`;
                html += `[${index}]: <span style="color: #405BFF; font-weight: 500;">${escapeHtml(varValue)}</span>`;
                html += `</div>`;
              });
            }
            
            if (flagValue.fallthrough) {
              if (flagValue.fallthrough.variation !== undefined) {
                html += `<div style="margin-top: 6px;">Default (fallthrough): <span style="color: #333;">variation ${flagValue.fallthrough.variation}</span></div>`;
              } else if (flagValue.fallthrough.rollout) {
                html += `<div style="margin-top: 6px;"><strong>Default (rollout):</strong></div>`;
                const rollout = flagValue.fallthrough.rollout;
                if (rollout.variations) {
                  rollout.variations.forEach((rv) => {
                    const percentage = (rv.weight / 1000).toFixed(1);
                    html += `<div style="margin-left: 12px; font-size: 10px;">`;
                    html += `Variation ${rv.variation}: ${percentage}%`;
                    html += `</div>`;
                  });
                }
              }
            }
            
            if (flagValue.offVariation !== undefined) {
              html += `<div>Off variation: <span style="color: #333;">variation ${flagValue.offVariation}</span></div>`;
            }
            
            if (flagValue.rules && flagValue.rules.length > 0) {
              html += `<div style="margin-top: 6px;"><strong>Rules (${flagValue.rules.length}):</strong></div>`;
              flagValue.rules.forEach((rule, index) => {
                html += `<div style="margin-left: 12px; font-size: 10px; margin-bottom: 4px;">`;
                html += `<strong>Rule ${index + 1}:</strong>`;
                
                if (rule.variation !== undefined) {
                  html += ` â†’ Variation ${rule.variation}`;
                } else if (rule.rollout) {
                  html += ` â†’ Rollout`;
                }
                
                if (rule.clauses && rule.clauses.length > 0) {
                  html += `<div style="margin-left: 12px; margin-top: 2px;">`;
                  rule.clauses.forEach((clause) => {
                    const negateText = clause.negate ? 'NOT ' : '';
                    const attribute = clause.attribute || 'key';
                    const op = clause.op || 'unknown';
                    const values = clause.values || [];
                    
                    html += `<div style="color: #666;">`;
                    html += `${negateText}${attribute} ${op} `;
                    
                    if (values.length === 1) {
                      html += `"${escapeHtml(values[0])}"`;
                    } else if (values.length > 1) {
                      html += `[${values.map(v => `"${escapeHtml(v)}"`).join(', ')}]`;
                    }
                    
                    html += `</div>`;
                  });
                  html += `</div>`;
                }
                
                html += `</div>`;
              });
            }
            
            if (flagValue.targets && flagValue.targets.length > 0) {
              html += `<div style="margin-top: 6px;"><strong>Targets (${flagValue.targets.length}):</strong></div>`;
              flagValue.targets.forEach((target) => {
                const userCount = target.values ? target.values.length : 0;
                html += `<div style="margin-left: 12px; font-size: 10px;">`;
                html += `Variation ${target.variation}: ${userCount} user(s)`;
                if (target.values && target.values.length > 0 && target.values.length <= 5) {
                  html += ` - ${target.values.map(v => escapeHtml(v)).join(', ')}`;
                } else if (target.values && target.values.length > 5) {
                  html += ` - ${target.values.slice(0, 5).map(v => escapeHtml(v)).join(', ')}, ...`;
                }
                html += `</div>`;
              });
            }
            
            if (flagValue.prerequisites && flagValue.prerequisites.length > 0) {
              html += `<div style="margin-top: 6px;"><strong>Prerequisites (${flagValue.prerequisites.length}):</strong></div>`;
              flagValue.prerequisites.forEach((prereq) => {
                html += `<div style="margin-left: 12px; font-size: 10px;">`;
                html += `${escapeHtml(prereq.key)} must be variation ${prereq.variation}`;
                html += `</div>`;
              });
            }
            
            html += `</div>`;
          } else {
            html += `<div style="font-size: 11px; color: #666; line-height: 1.8;">`;
            html += `<div>Value: <span style="color: #333; font-weight: 500;">${escapeHtml(JSON.stringify(flagValue))}</span></div>`;
            html += `</div>`;
          }
          
          html += `</div>`;
        });
        html += '</div>';
        
        return html;
      }
      
      // Connect to Relay Proxy cache SSE stream for real-time updates
      let relayProxyCacheEventSource = null;
      let nodeSdkCacheEventSource = null;
      let redisCacheEventSource = null;
      
      function connectRelayProxyCacheStream() {
        const cacheElement = document.getElementById('relay-proxy-cache');
        
        if (!cacheElement) {
          console.error('Relay Proxy cache element not found');
          return;
        }
        
        // Close existing connection if any
        if (relayProxyCacheEventSource) {
          relayProxyCacheEventSource.close();
        }
        
        // Show loading state
        cacheElement.innerHTML = '<div style="color: #999; font-style: italic;">Connecting...</div>';
        
        try {
          relayProxyCacheEventSource = new EventSource('http://localhost:4000/api/relay-proxy/cache/stream');
          
          relayProxyCacheEventSource.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              
              if (data.error) {
                cacheElement.innerHTML = `<div style="color: #f44336;">Error: ${data.error}</div>`;
                return;
              }
              
              if (data.flags) {
                console.log('[Relay Proxy Cache] Received update:', Object.keys(data.flags).length, 'flags');
                renderRelayProxyCache(data.flags);
                
                // Also update Redis display since Redis is updated by Relay Proxy
                console.log('[Relay Proxy Cache] Also updating Redis display');
                renderRedisDataStore(data.flags);
                
                // Also update PHP display since PHP reads from Redis
                console.log('[Relay Proxy Cache] Also updating PHP SDK cache display');
                renderPHPSDKCache(data.flags);
              }
            } catch (error) {
              console.error('Error parsing Relay Proxy cache update:', error);
            }
          };
          
          relayProxyCacheEventSource.onerror = (error) => {
            console.error('Relay Proxy cache SSE error:', error);
            cacheElement.innerHTML = '<div style="color: #f44336;">Connection error - retrying...</div>';
            
            // Reconnect after 5 seconds
            setTimeout(() => {
              if (relayProxyCacheEventSource && relayProxyCacheEventSource.readyState === EventSource.CLOSED) {
                connectRelayProxyCacheStream();
              }
            }, 5000);
          };
          
          console.log('[Relay Proxy Cache] SSE stream connected');
        } catch (error) {
          console.error('Error connecting to Relay Proxy cache stream:', error);
          cacheElement.innerHTML = `<div style="color: #f44336;">Error: ${error.message}</div>`;
        }
      }
      
      function connectNodeSdkCacheStream() {
        const cacheElement = document.getElementById('node-sdk-cache');
        
        if (!cacheElement) {
          console.error('Node SDK cache element not found');
          return;
        }
        
        // Close existing connection if any
        if (nodeSdkCacheEventSource) {
          nodeSdkCacheEventSource.close();
        }
        
        // Show loading state
        cacheElement.innerHTML = '<div style="color: #999; font-style: italic;">Connecting...</div>';
        
        try {
          nodeSdkCacheEventSource = new EventSource('http://localhost:3000/api/node/sdk-cache/stream');
          
          nodeSdkCacheEventSource.onmessage = (event) => {
            try {
              const data = JSON.parse(event.data);
              
              if (data.error) {
                cacheElement.innerHTML = `<div style="color: #f44336;">Error: ${data.error}</div>`;
                return;
              }
              
              if (data.flags) {
                console.log('[Node SDK Cache] Received update:', Object.keys(data.flags).length, 'flags');
                renderNodeSDKCache(data.flags);
              }
            } catch (error) {
              console.error('Error parsing Node SDK cache update:', error);
            }
          };
          
          nodeSdkCacheEventSource.onerror = (error) => {
            console.error('Node SDK cache SSE error:', error);
            cacheElement.innerHTML = '<div style="color: #f44336;">Connection error - retrying...</div>';
            
            // Reconnect after 5 seconds
            setTimeout(() => {
              if (nodeSdkCacheEventSource && nodeSdkCacheEventSource.readyState === EventSource.CLOSED) {
                connectNodeSdkCacheStream();
              }
            }, 5000);
          };
          
          console.log('[Node SDK Cache] SSE stream connected');
        } catch (error) {
          console.error('Error connecting to Node SDK cache stream:', error);
          cacheElement.innerHTML = `<div style="color: #f44336;">Error: ${error.message}</div>`;
        }
      }
      
      // Track Redis connection state for detecting transitions
      let wasRedisConnected = false;
      
      async function pollRedisStatus() {
        try {
          const response = await fetch('http://localhost:4000/api/redis/status');
          const statusIndicator = document.getElementById('redis-status');
          const statusText = document.getElementById('redis-status-text');
          const startButton = document.getElementById('redis-start-button');
          const stopButton = document.getElementById('redis-stop-button');
          const restartButton = document.getElementById('redis-restart-button');
          
          if (response.ok) {
            const data = await response.json();
            const isConnected = data.connected && data.running;
            
            if (isConnected) {
              // Redis is running
              updatePillStatus('redis', 'connected');
              statusText.textContent = 'Running';
              statusText.style.color = '#4caf50';
              
              // Show stop and restart buttons, hide start
              if (startButton) startButton.style.display = 'none';
              if (stopButton) stopButton.style.display = 'flex';
              if (restartButton) restartButton.style.display = 'flex';
              
              // If Redis just came back online, manually fetch the data store
              if (!wasRedisConnected && isConnected) {
                console.log('[Redis] Service reconnected, fetching data store manually');
                const dataStoreElement = document.getElementById('redis-data-store');
                if (dataStoreElement && 
                    (dataStoreElement.innerHTML.includes('Waiting for Redis') || 
                     dataStoreElement.innerHTML.includes('not responding'))) {
                  // Fetch from Relay Proxy cache endpoint (POST method)
                  try {
                    const cacheResponse = await fetch('http://localhost:4000/api/relay-proxy/cache', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' }
                    });
                    if (cacheResponse.ok) {
                      const cacheData = await cacheResponse.json();
                      if (cacheData.flags) {
                        console.log('[Redis] Data store fetched successfully:', Object.keys(cacheData.flags).length, 'flags');
                        window.renderRedisDataStore(cacheData.flags);
                      }
                    }
                  } catch (error) {
                    console.error('[Redis] Error fetching data store:', error);
                  }
                }
              }
              
              wasRedisConnected = true;
            } else if (data.running === false) {
              // Redis container exists but is stopped
              updatePillStatus('redis', 'stopped');
              statusText.textContent = 'Stopped';
              statusText.style.color = '#999';
              
              // Show start button, hide stop and restart
              if (startButton) startButton.style.display = 'flex';
              if (stopButton) stopButton.style.display = 'none';
              if (restartButton) restartButton.style.display = 'none';
              
              // Show waiting message when stopped
              const dataStoreElement = document.getElementById('redis-data-store');
              if (dataStoreElement) {
                dataStoreElement.innerHTML = '<div style="color: #999; font-style: italic;">Waiting for Redis to initialize...</div>';
              }
              
              wasRedisConnected = false;
            } else {
              // Redis is not responding
              updatePillStatus('redis', 'disconnected');
              statusText.textContent = 'Disconnected';
              statusText.style.color = '#f44336';
              
              // Show all buttons
              if (startButton) startButton.style.display = 'flex';
              if (stopButton) stopButton.style.display = 'flex';
              if (restartButton) restartButton.style.display = 'flex';
              
              // Show error message when disconnected
              const dataStoreElement = document.getElementById('redis-data-store');
              if (dataStoreElement) {
                dataStoreElement.innerHTML = '<div style="color: #f44336;">Redis is not responding</div>';
              }
              
              wasRedisConnected = false;
            }
          } else {
            updatePillStatus('redis', 'disconnected');
            statusText.textContent = 'Disconnected';
            statusText.style.color = '#f44336';
            
            // Show all buttons
            if (startButton) startButton.style.display = 'flex';
            if (stopButton) stopButton.style.display = 'flex';
            if (restartButton) restartButton.style.display = 'flex';
            
            // Show error message
            const dataStoreElement = document.getElementById('redis-data-store');
            if (dataStoreElement) {
              dataStoreElement.innerHTML = '<div style="color: #f44336;">Redis is not responding</div>';
            }
            
            wasRedisConnected = false;
          }
        } catch (error) {
          const statusIndicator = document.getElementById('redis-status');
          const statusText = document.getElementById('redis-status-text');
          const startButton = document.getElementById('redis-start-button');
          const stopButton = document.getElementById('redis-stop-button');
          const restartButton = document.getElementById('redis-restart-button');
          
          updatePillStatus('redis', 'disconnected');
          statusText.textContent = 'Disconnected';
          statusText.style.color = '#f44336';
          
          // Show all buttons
          if (startButton) startButton.style.display = 'flex';
          if (stopButton) stopButton.style.display = 'flex';
          if (restartButton) restartButton.style.display = 'flex';
          
          // Show error message
          const dataStoreElement = document.getElementById('redis-data-store');
          if (dataStoreElement) {
            dataStoreElement.innerHTML = '<div style="color: #f44336;">Error connecting to Redis</div>';
          }
          
          wasRedisConnected = false;
        }
      }
      
      // Poll immediately and then every 5 seconds
      updateRelayProxyStatus();
      setInterval(updateRelayProxyStatus, 5000);
      
      pollRedisStatus();
      setInterval(pollRedisStatus, 5000);
      
      pollNodeContainerStatus();
      setInterval(pollNodeContainerStatus, 5000);
      
      pollPhpContainerStatus();
      setInterval(pollPhpContainerStatus, 5000);
      
      // Only poll Python if it's the active service in Panel 1
      if (window.currentPanelService === 'python') {
        pollPythonContainerStatus();
        setInterval(pollPythonContainerStatus, 5000);
      }
      
      // Set up Redis control button handlers
      const redisStartButton = document.getElementById('redis-start-button');
      const redisStopButton = document.getElementById('redis-stop-button');
      const redisRestartButton = document.getElementById('redis-restart-button');
      
      if (redisStartButton) {
        redisStartButton.addEventListener('click', async () => {
          redisStartButton.disabled = true;
          const originalText = redisStartButton.textContent;
          redisStartButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/redis/start', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await pollRedisStatus();
            } else {
              alert(`Failed to start Redis: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error starting Redis: ${error.message}`);
          } finally {
            redisStartButton.disabled = false;
            redisStartButton.textContent = originalText;
          }
        });
      }
      
      if (redisStopButton) {
        redisStopButton.addEventListener('click', async () => {
          redisStopButton.disabled = true;
          const originalText = redisStopButton.textContent;
          redisStopButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/redis/stop', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await pollRedisStatus();
            } else {
              alert(`Failed to stop Redis: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error stopping Redis: ${error.message}`);
          } finally {
            redisStopButton.disabled = false;
            redisStopButton.textContent = originalText;
          }
        });
      }
      
      if (redisRestartButton) {
        redisRestartButton.addEventListener('click', async () => {
          redisRestartButton.disabled = true;
          const originalText = redisRestartButton.textContent;
          redisRestartButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/redis/restart', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await pollRedisStatus();
            } else {
              alert(`Failed to restart Redis: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error restarting Redis: ${error.message}`);
          } finally {
            redisRestartButton.disabled = false;
            redisRestartButton.textContent = originalText;
          }
        });
      }
      
      // Set up Relay Proxy control button handlers
      const relayProxyStartButton = document.getElementById('relay-proxy-start-button');
      const relayProxyStopButton = document.getElementById('relay-proxy-stop-button');
      const relayProxyRestartButton = document.getElementById('relay-proxy-restart-button');
      
      if (relayProxyStartButton) {
        relayProxyStartButton.addEventListener('click', async () => {
          relayProxyStartButton.disabled = true;
          const originalText = relayProxyStartButton.textContent;
          relayProxyStartButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/relay-proxy/start', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await updateRelayProxyStatus();
            } else {
              alert(`Failed to start Relay Proxy: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error starting Relay Proxy: ${error.message}`);
          } finally {
            relayProxyStartButton.disabled = false;
            relayProxyStartButton.textContent = originalText;
          }
        });
      }
      
      if (relayProxyStopButton) {
        relayProxyStopButton.addEventListener('click', async () => {
          relayProxyStopButton.disabled = true;
          const originalText = relayProxyStopButton.textContent;
          relayProxyStopButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/relay-proxy/stop', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await updateRelayProxyStatus();
            } else {
              alert(`Failed to stop Relay Proxy: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error stopping Relay Proxy: ${error.message}`);
          } finally {
            relayProxyStopButton.disabled = false;
            relayProxyStopButton.textContent = originalText;
          }
        });
      }
      
      if (relayProxyRestartButton) {
        relayProxyRestartButton.addEventListener('click', async () => {
          relayProxyRestartButton.disabled = true;
          const originalText = relayProxyRestartButton.textContent;
          relayProxyRestartButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/relay-proxy/restart', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await updateRelayProxyStatus();
            } else {
              alert(`Failed to restart Relay Proxy: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error restarting Relay Proxy: ${error.message}`);
          } finally {
            relayProxyRestartButton.disabled = false;
            relayProxyRestartButton.textContent = originalText;
          }
        });
      }
      
      // Node.js container status polling
      async function pollNodeContainerStatus() {
        try {
          const response = await fetch('http://localhost:4000/api/node/container-status');
          const statusIndicator = document.getElementById('node-status');
          const startButton = document.getElementById('node-start-button');
          const stopButton = document.getElementById('node-stop-button');
          const restartButton = document.getElementById('node-restart-button');
          
          if (response.ok) {
            const data = await response.json();
            if (data.connected && data.running) {
              // Node.js container is running
              updatePillStatus('node', 'connected');
              
              // Show stop and restart buttons, hide start
              if (startButton) startButton.style.display = 'none';
              if (stopButton) stopButton.style.display = 'flex';
              if (restartButton) restartButton.style.display = 'flex';
              // Show action buttons
              const contextButton = document.getElementById('node-context-button');
              const testButton = document.getElementById('node-test-evaluation');
              const viewCacheButton = document.getElementById('node-view-cache');
              if (contextButton) contextButton.style.display = 'inline-block';
              if (testButton) testButton.style.display = 'inline-block';
              if (viewCacheButton) viewCacheButton.style.display = 'inline-block';
              
              // Connect to Node SDK cache SSE stream when connected (only if Node panel is displayed)
              if (window.currentPanelService !== 'python') {
                if (!nodeSdkCacheEventSource || nodeSdkCacheEventSource.readyState === EventSource.CLOSED) {
                  connectNodeSdkCacheStream();
                }
              }
            } else if (data.running === false) {
              // Node.js container exists but is stopped
              updatePillStatus('node', 'stopped');
              
              // Show start button, hide stop and restart
              if (startButton) startButton.style.display = 'flex';
              if (stopButton) stopButton.style.display = 'none';
              if (restartButton) restartButton.style.display = 'none';
              
              // Hide action buttons
              const contextButton = document.getElementById('node-context-button');
              const testButton = document.getElementById('node-test-evaluation');
              const viewCacheButton = document.getElementById('node-view-cache');
              if (contextButton) contextButton.style.display = 'none';
              if (testButton) testButton.style.display = 'none';
              if (viewCacheButton) viewCacheButton.style.display = 'none';
            } else {
              // Node.js is not responding
              updatePillStatus('node', 'disconnected');
              
              // Show all buttons
              if (startButton) startButton.style.display = 'flex';
              if (stopButton) stopButton.style.display = 'flex';
              if (restartButton) restartButton.style.display = 'flex';
              
              // Hide action buttons
              const contextButton = document.getElementById('node-context-button');
              const testButton = document.getElementById('node-test-evaluation');
              const viewCacheButton = document.getElementById('node-view-cache');
              if (contextButton) contextButton.style.display = 'none';
              if (testButton) testButton.style.display = 'none';
              if (viewCacheButton) viewCacheButton.style.display = 'none';
            }
          } else {
            updatePillStatus('node', 'disconnected');
            
            // Show all buttons
            if (startButton) startButton.style.display = 'flex';
            if (stopButton) stopButton.style.display = 'flex';
            if (restartButton) restartButton.style.display = 'flex';
            
            // Hide action buttons
            const contextButton = document.getElementById('node-context-button');
            const testButton = document.getElementById('node-test-evaluation');
            const viewCacheButton = document.getElementById('node-view-cache');
            if (contextButton) contextButton.style.display = 'none';
            if (testButton) testButton.style.display = 'none';
            if (viewCacheButton) viewCacheButton.style.display = 'none';
          }
        } catch (error) {
          const statusIndicator = document.getElementById('node-status');
          const startButton = document.getElementById('node-start-button');
          const stopButton = document.getElementById('node-stop-button');
          const restartButton = document.getElementById('node-restart-button');
          
          updatePillStatus('node', 'disconnected');
          
          // Show all buttons
          if (startButton) startButton.style.display = 'flex';
          if (stopButton) stopButton.style.display = 'flex';
          if (restartButton) restartButton.style.display = 'flex';
          
          // Hide action buttons
          const contextButton = document.getElementById('node-context-button');
          const testButton = document.getElementById('node-test-evaluation');
          const viewCacheButton = document.getElementById('node-view-cache');
          if (contextButton) contextButton.style.display = 'none';
          if (testButton) testButton.style.display = 'none';
          if (viewCacheButton) viewCacheButton.style.display = 'none';
        }
      }
      
      // Set up Node.js control button handlers
      const nodeStartButton = document.getElementById('node-start-button');
      const nodeStopButton = document.getElementById('node-stop-button');
      const nodeRestartButton = document.getElementById('node-restart-button');
      
      if (nodeStartButton) {
        nodeStartButton.addEventListener('click', async () => {
          nodeStartButton.disabled = true;
          const originalText = nodeStartButton.textContent;
          nodeStartButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/node/start', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await pollNodeContainerStatus();
            } else {
              alert(`Failed to start Node.js Service: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error starting Node.js Service: ${error.message}`);
          } finally {
            nodeStartButton.disabled = false;
            nodeStartButton.textContent = originalText;
          }
        });
      }
      
      if (nodeStopButton) {
        nodeStopButton.addEventListener('click', async () => {
          nodeStopButton.disabled = true;
          const originalText = nodeStopButton.textContent;
          nodeStopButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/node/stop', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await pollNodeContainerStatus();
            } else {
              alert(`Failed to stop Node.js Service: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error stopping Node.js Service: ${error.message}`);
          } finally {
            nodeStopButton.disabled = false;
            nodeStopButton.textContent = originalText;
          }
        });
      }
      
      if (nodeRestartButton) {
        nodeRestartButton.addEventListener('click', async () => {
          nodeRestartButton.disabled = true;
          const originalText = nodeRestartButton.textContent;
          nodeRestartButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/node/restart', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await pollNodeContainerStatus();
            } else {
              alert(`Failed to restart Node.js Service: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error restarting Node.js Service: ${error.message}`);
          } finally {
            nodeRestartButton.disabled = false;
            nodeRestartButton.textContent = originalText;
          }
        });
      }
      
      // PHP container status polling
      async function pollPhpContainerStatus() {
        try {
          const response = await fetch('http://localhost:4000/api/php/container-status');
          const statusIndicator = document.getElementById('php-status');
          const startButton = document.getElementById('php-start-button');
          const stopButton = document.getElementById('php-stop-button');
          const restartButton = document.getElementById('php-restart-button');
          
          if (response.ok) {
            const data = await response.json();
            if (data.connected && data.running) {
              // PHP container is running
              updatePillStatus('php', 'connected');
              
              // Show stop and restart buttons, hide start
              if (startButton) startButton.style.display = 'none';
              if (stopButton) stopButton.style.display = 'flex';
              if (restartButton) restartButton.style.display = 'flex';
              
              // Show action buttons
              const contextButton = document.getElementById('php-edit-context');
              const testButton = document.getElementById('php-test-evaluation');
              const viewCacheButton = document.getElementById('php-view-cache');
              if (contextButton) contextButton.style.display = 'inline-block';
              if (testButton) testButton.style.display = 'inline-block';
              if (viewCacheButton) viewCacheButton.style.display = 'inline-block';
            } else if (data.running === false) {
              // PHP container exists but is stopped
              updatePillStatus('php', 'stopped');
              
              // Show start button, hide stop and restart
              if (startButton) startButton.style.display = 'flex';
              if (stopButton) stopButton.style.display = 'none';
              if (restartButton) restartButton.style.display = 'none';
              
              // Hide action buttons
              const contextButton = document.getElementById('php-edit-context');
              const testButton = document.getElementById('php-test-evaluation');
              const viewCacheButton = document.getElementById('php-view-cache');
              if (contextButton) contextButton.style.display = 'none';
              if (testButton) testButton.style.display = 'none';
              if (viewCacheButton) viewCacheButton.style.display = 'none';
            } else {
              // PHP is not responding
              updatePillStatus('php', 'disconnected');
              
              // Show all buttons
              if (startButton) startButton.style.display = 'flex';
              if (stopButton) stopButton.style.display = 'flex';
              if (restartButton) restartButton.style.display = 'flex';
              
              // Hide action buttons
              const contextButton = document.getElementById('php-edit-context');
              const testButton = document.getElementById('php-test-evaluation');
              const viewCacheButton = document.getElementById('php-view-cache');
              if (contextButton) contextButton.style.display = 'none';
              if (testButton) testButton.style.display = 'none';
              if (viewCacheButton) viewCacheButton.style.display = 'none';
            }
          } else {
            updatePillStatus('php', 'disconnected');
            
            // Show all buttons
            if (startButton) startButton.style.display = 'flex';
            if (stopButton) stopButton.style.display = 'flex';
            if (restartButton) restartButton.style.display = 'flex';
            
            // Hide action buttons
            const contextButton = document.getElementById('php-edit-context');
            const testButton = document.getElementById('php-test-evaluation');
            const viewCacheButton = document.getElementById('php-view-cache');
            if (contextButton) contextButton.style.display = 'none';
            if (testButton) testButton.style.display = 'none';
            if (viewCacheButton) viewCacheButton.style.display = 'none';
          }
        } catch (error) {
          const statusIndicator = document.getElementById('php-status');
          const startButton = document.getElementById('php-start-button');
          const stopButton = document.getElementById('php-stop-button');
          const restartButton = document.getElementById('php-restart-button');
          
          updatePillStatus('php', 'disconnected');
          
          // Show all buttons
          if (startButton) startButton.style.display = 'flex';
          if (stopButton) stopButton.style.display = 'flex';
          if (restartButton) restartButton.style.display = 'flex';
          
          // Hide action buttons
          const contextButton = document.getElementById('php-edit-context');
          const testButton = document.getElementById('php-test-evaluation');
          const viewCacheButton = document.getElementById('php-view-cache');
          if (contextButton) contextButton.style.display = 'none';
          if (testButton) testButton.style.display = 'none';
          if (viewCacheButton) viewCacheButton.style.display = 'none';
        }
      }
      
      // Python container status polling
      async function pollPythonContainerStatus() {
        try {
          const response = await fetch('http://localhost:4000/api/python/container-status');
          const statusIndicator = document.getElementById('python-status');
          const startButton = document.getElementById('python-start-button');
          const stopButton = document.getElementById('python-stop-button');
          const restartButton = document.getElementById('python-restart-button');
          
          if (response.ok) {
            const data = await response.json();
            if (data.connected && data.running) {
              // Python container is running
              updatePillStatus('python', 'connected');
              
              // Show stop and restart buttons, hide start
              if (startButton) {
                startButton.style.display = 'none';
                startButton.disabled = false;
              }
              if (stopButton) {
                stopButton.style.display = 'flex';
                stopButton.disabled = false;
              }
              if (restartButton) {
                restartButton.style.display = 'flex';
                restartButton.disabled = false;
              }
            } else if (data.running === false) {
              // Python container exists but is stopped
              updatePillStatus('python', 'stopped');
              
              // Show start button, hide stop and restart
              if (startButton) {
                startButton.style.display = 'flex';
                startButton.disabled = false;
              }
              if (stopButton) {
                stopButton.style.display = 'none';
                stopButton.disabled = false;
              }
              if (restartButton) {
                restartButton.style.display = 'none';
                restartButton.disabled = false;
              }
            } else {
              // Python is not responding
              updatePillStatus('python', 'disconnected');
              
              // Show all buttons
              if (startButton) {
                startButton.style.display = 'flex';
                startButton.disabled = false;
              }
              if (stopButton) {
                stopButton.style.display = 'flex';
                stopButton.disabled = false;
              }
              if (restartButton) {
                restartButton.style.display = 'flex';
                restartButton.disabled = false;
              }
            }
          } else {
            updatePillStatus('python', 'disconnected');
            
            // Show all buttons
            if (startButton) {
              startButton.style.display = 'flex';
              startButton.disabled = false;
            }
            if (stopButton) {
              stopButton.style.display = 'flex';
              stopButton.disabled = false;
            }
            if (restartButton) {
              restartButton.style.display = 'flex';
              restartButton.disabled = false;
            }
          }
        } catch (error) {
          const statusIndicator = document.getElementById('python-status');
          const startButton = document.getElementById('python-start-button');
          const stopButton = document.getElementById('python-stop-button');
          const restartButton = document.getElementById('python-restart-button');
          
          updatePillStatus('python', 'disconnected');
          
          // Show all buttons
          if (startButton) {
            startButton.style.display = 'flex';
            startButton.disabled = false;
          }
          if (stopButton) {
            stopButton.style.display = 'flex';
            stopButton.disabled = false;
          }
          if (restartButton) {
            restartButton.style.display = 'flex';
            restartButton.disabled = false;
          }
        }
      }
      
      // Set up PHP control button handlers
      const phpStartButton = document.getElementById('php-start-button');
      const phpStopButton = document.getElementById('php-stop-button');
      const phpRestartButton = document.getElementById('php-restart-button');
      
      if (phpStartButton) {
        phpStartButton.addEventListener('click', async () => {
          phpStartButton.disabled = true;
          const originalText = phpStartButton.textContent;
          phpStartButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/php/start', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await pollPhpContainerStatus();
            } else {
              alert(`Failed to start PHP Service: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error starting PHP Service: ${error.message}`);
          } finally {
            phpStartButton.disabled = false;
            phpStartButton.textContent = originalText;
          }
        });
      }
      
      if (phpStopButton) {
        phpStopButton.addEventListener('click', async () => {
          phpStopButton.disabled = true;
          const originalText = phpStopButton.textContent;
          phpStopButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/php/stop', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await pollPhpContainerStatus();
            } else {
              alert(`Failed to stop PHP Service: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error stopping PHP Service: ${error.message}`);
          } finally {
            phpStopButton.disabled = false;
            phpStopButton.textContent = originalText;
          }
        });
      }
      
      if (phpRestartButton) {
        phpRestartButton.addEventListener('click', async () => {
          phpRestartButton.disabled = true;
          const originalText = phpRestartButton.textContent;
          phpRestartButton.textContent = '...';
          
          try {
            const response = await fetch('http://localhost:4000/api/php/restart', {
              method: 'POST'
            });
            const data = await response.json();
            
            if (data.success) {
              
              // Refresh status immediately
              await pollPhpContainerStatus();
            } else {
              alert(`Failed to restart PHP Service: ${data.error || 'Unknown error'}`);
            }
          } catch (error) {
            alert(`Error restarting PHP Service: ${error.message}`);
          } finally {
            phpRestartButton.disabled = false;
            phpRestartButton.textContent = originalText;
          }
        });
      }
      
      // Fetch contexts FIRST to establish sessions
      console.log('[Dashboard] Fetching initial contexts...');
      await nodePanel.fetchCurrentContext();
      await phpPanel.fetchCurrentContext();
      console.log('[Dashboard] Initial contexts fetched');
      console.log('[Dashboard] Node context:', nodePanel.currentContext);
      console.log('[Dashboard] PHP context:', phpPanel.currentContext);
      
      // Wait a moment for SDKs to fully initialize (3 seconds to be safe)
      console.log('[Dashboard] Waiting 3 seconds for SDKs to initialize...');
      await new Promise(resolve => setTimeout(resolve, 3000));
      console.log('[Dashboard] SDKs should be initialized');
      
      // NOW connect to SSE streams (they will use the established sessions and initialized SDKs)
      console.log('[Dashboard] Connecting SSE streams...');
      
      // Connect Node.js stream
      nodePanel.connectStream();
      console.log('[Dashboard] Node stream connected');
      
      // Add small delay before connecting PHP stream to avoid race conditions
      setTimeout(() => {
        phpPanel.connectStream();
        console.log('[Dashboard] PHP stream connected');
      }, 100);
      
      // Connect Python stream if it's the active panel
      if (window.currentPanelService === 'python') {
        setTimeout(() => {
          pythonPanel.connectStream();
          console.log('[Dashboard] Python stream connected');
        }, 200);
      }
      
      // Start status polling (but skip initial context fetch since we already did it)
      nodePanel.startStatusPolling();
      phpPanel.startStatusPolling();
      pythonPanel.startStatusPolling();
      
      // Function to initialize/reinitialize Panel 1 log console based on current service
      function initializePanel1LogConsole() {
        console.log('[Dashboard] Initializing Panel 1 log console for:', window.currentPanelService);
        
        // Stop and clean up existing console if it exists
        if (appDevConsole) {
          appDevConsole.stop();
        }
        
        // Determine container and output IDs based on current service
        const panel1ContainerName = window.currentPanelService === 'python' ? 'python-app-dev' : 'node-app-dev';
        const panel1OutputId = window.currentPanelService === 'python' ? 'python-app-dev-output' : 'node-app-dev-output';
        
        // Create new log console for Panel 1
        appDevConsole = new LogConsole(panel1ContainerName, panel1OutputId, 'polling');
        appDevConsole.start();
        
        // Set up clear button handler for Panel 1
        const panel1ClearBtnId = window.currentPanelService === 'python' ? 'python-app-dev-clear' : 'node-app-dev-clear';
        const appDevClearBtn = document.getElementById(panel1ClearBtnId);
        if (appDevClearBtn) {
          // Remove old event listener by cloning the button
          const newBtn = appDevClearBtn.cloneNode(true);
          appDevClearBtn.parentNode.replaceChild(newBtn, appDevClearBtn);
          
          // Add new event listener
          newBtn.addEventListener('click', () => {
            appDevConsole.clear();
          });
        }
        
        console.log('[Dashboard] Panel 1 log console initialized');
      }
      
      // Make function globally accessible for flag change handler
      window.initializePanel1LogConsole = initializePanel1LogConsole;
      
      // Initialize Panel 1 log console now (on initial page load)
      initializePanel1LogConsole();
      
      // Create other log console instances (Panel 2, 3, 4)
      phpAppDevConsole = new LogConsole('php-app-dev', 'php-app-dev-output', 'polling');
      relayProxyConsole = new LogConsole('relay-proxy', 'relay-proxy-output', 'polling');
      redisMonitorConsole = new LogConsole('redis', 'redis-monitor-output', 'sse');
      
      // Start other log consoles
      phpAppDevConsole.start();
      relayProxyConsole.start();
      redisMonitorConsole.start();
      
      // Initialize relay proxy connection control
      console.log('[Dashboard] Initializing relay proxy connection control...');
      const relayProxyConnectionControl = new RelayProxyConnectionControl();
      console.log('[Dashboard] Relay proxy connection control initialized');
      
      // Set up clear button handlers for other panels
      const phpAppDevClearBtn = document.getElementById('php-app-dev-clear');
      if (phpAppDevClearBtn) {
        phpAppDevClearBtn.addEventListener('click', () => {
          phpAppDevConsole.clear();
        });
      }
      
      const relayProxyClearBtn = document.getElementById('relay-proxy-clear');
      if (relayProxyClearBtn) {
        relayProxyClearBtn.addEventListener('click', () => {
          relayProxyConsole.clear();
        });
      }
      
      const redisMonitorClearBtn = document.getElementById('redis-monitor-clear');
      if (redisMonitorClearBtn) {
        redisMonitorClearBtn.addEventListener('click', () => {
          redisMonitorConsole.clear();
        });
      }
      
      // Set up context button handlers
      const nodeContextButton = document.getElementById('node-context-button');
      if (nodeContextButton) {
        nodeContextButton.addEventListener('click', () => {
          nodePanel.openContextEditor();
        });
      }
      
      const phpContextButton = document.getElementById('php-edit-context');
      if (phpContextButton) {
        phpContextButton.addEventListener('click', () => {
          phpPanel.openContextEditor();
        });
      }
      
      const pythonContextButton = document.getElementById('python-context-button');
      if (pythonContextButton) {
        pythonContextButton.addEventListener('click', () => {
          pythonPanel.openContextEditor();
        });
      }
      
      // Set up hash toggle handlers
      const nodeHashToggle = document.getElementById('node-hash-toggle');
      const nodeHashContent = document.getElementById('node-hash-content');
      const nodeSdkCache = document.getElementById('node-sdk-cache');
      if (nodeHashToggle && nodeHashContent) {
        nodeHashToggle.addEventListener('click', (e) => {
          e.preventDefault();
          if (nodeHashContent.style.display === 'none') {
            nodeHashContent.style.display = 'block';
            nodeHashToggle.textContent = 'Hide';
            // Shrink SDK cache to make room for hash section
            if (nodeSdkCache) {
              nodeSdkCache.style.maxHeight = '150px';
            }
          } else {
            nodeHashContent.style.display = 'none';
            nodeHashToggle.textContent = 'Show';
            // Restore SDK cache height
            if (nodeSdkCache) {
              nodeSdkCache.style.maxHeight = '280px';
            }
          }
        });
      }
      
      const phpHashToggle = document.getElementById('php-hash-toggle');
      const phpHashContent = document.getElementById('php-hash-content');
      const phpSdkCache = document.getElementById('php-sdk-cache');
      if (phpHashToggle && phpHashContent) {
        phpHashToggle.addEventListener('click', (e) => {
          e.preventDefault();
          if (phpHashContent.style.display === 'none') {
            phpHashContent.style.display = 'block';
            phpHashToggle.textContent = 'Hide';
            // Shrink SDK cache to make room for hash section
            if (phpSdkCache) {
              phpSdkCache.style.maxHeight = '150px';
            }
          } else {
            phpHashContent.style.display = 'none';
            phpHashToggle.textContent = 'Show';
            // Restore SDK cache height
            if (phpSdkCache) {
              phpSdkCache.style.maxHeight = '280px';
            }
          }
        });
      }
      
      // PHP Test Evaluation button
      const phpTestButton = document.getElementById('php-test-evaluation');
      if (phpTestButton) {
        phpTestButton.addEventListener('click', async () => {
          phpTestButton.disabled = true;
          phpTestButton.textContent = 'Testing...';
          
          try {
            // Log the current context before sending
            console.log('Sending context to PHP test evaluation:', phpPanel.currentContext);
            
            // Send the current context from the panel
            const response = await fetch('http://localhost:4000/api/php/test-evaluation', {
              method: 'POST',
              credentials: 'include',  // Include cookies for session
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                context: phpPanel.currentContext
              })
            });
            
            const data = await response.json();
            
            if (data.success) {
              // Update the PHP panel flag display with the evaluated value
              const phpFlagElement = document.getElementById('php-flag-value');
              if (phpFlagElement) {
                phpFlagElement.textContent = data.flagValue;
              }
              
              // Update hash info if available
              if (data.hashInfo) {
                phpPanel.updateHashInfo(data.hashInfo);
              }
              
              // Build context details for alert
              let contextDetails = `- Type: ${data.context.type}\n- Key: ${data.context.key}\n- Anonymous: ${data.context.anonymous}`;
              if (data.context.email) {
                contextDetails += `\n- Email: ${data.context.email}`;
              }
              if (data.context.name) {
                contextDetails += `\n- Name: ${data.context.name}`;
              }
              if (data.context.location) {
                contextDetails += `\n- Location: ${data.context.location} âœ“`;
              }
              
              // Add hash info to alert if available
              let hashDetails = '';
              if (data.hashInfo) {
                hashDetails = `\n\nHash Values:\n- Hash: ${data.hashInfo.hashValue}\n- Bucket: ${data.hashInfo.bucketValue.toFixed(5)}\n- Salt: ${data.hashInfo.salt}`;
              }
              
              alert(`Test Evaluation Complete!\n\nFlag Value: ${data.flagValue}\n\nContext:\n${contextDetails}${hashDetails}\n\nCheck the php-app-dev logs for detailed output.`);
            } else {
              alert(`Test Evaluation Failed:\n${data.error}`);
            }
          } catch (error) {
            alert(`Error: ${error.message}`);
          } finally {
            phpTestButton.disabled = false;
            phpTestButton.textContent = 'Test Flag Evaluation';
          }
        });
      }
      
      // Node.js Test Evaluation button
      const nodeTestButton = document.getElementById('node-test-evaluation');
      if (nodeTestButton) {
        nodeTestButton.addEventListener('click', async () => {
          nodeTestButton.disabled = true;
          nodeTestButton.textContent = 'Testing...';
          
          try {
            // Log the current context before sending
            console.log('Sending context to test evaluation:', nodePanel.currentContext);
            
            // Send the current context from the panel
            const response = await fetch('http://localhost:3000/api/node/test-evaluation', {
              method: 'POST',
              credentials: 'include',  // Include cookies for session
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                context: nodePanel.currentContext
              })
            });
            
            const data = await response.json();
            
            if (data.success) {
              // Update the Node.js panel flag display with the evaluated value
              const nodeFlagElement = document.getElementById('node-flag-value');
              if (nodeFlagElement) {
                nodeFlagElement.textContent = data.flagValue;
              }
              
              // Update hash info if available
              if (data.hashInfo) {
                nodePanel.updateHashInfo(data.hashInfo);
              }
              
              // Build context details for alert
              let contextDetails = `- Type: ${data.context.type}\n- Key: ${data.context.key}\n- Anonymous: ${data.context.anonymous}`;
              if (data.context.email) {
                contextDetails += `\n- Email: ${data.context.email}`;
              }
              if (data.context.name) {
                contextDetails += `\n- Name: ${data.context.name}`;
              }
              if (data.context.location) {
                contextDetails += `\n- Location: ${data.context.location} âœ“`;
              }
              
              // Add hash info to alert if available
              let hashDetails = '';
              if (data.hashInfo) {
                hashDetails = `\n\nHash Values:\n- Hash: ${data.hashInfo.hashValue}\n- Bucket: ${data.hashInfo.bucketValue.toFixed(5)}\n- Salt: ${data.hashInfo.salt}`;
              }
              
              alert(`Test Evaluation Complete!\n\nFlag Value: ${data.flagValue}\n\nContext:\n${contextDetails}${hashDetails}\n\nCheck the node-app-dev logs for detailed output.`);
            } else {
              alert(`Test Evaluation Failed:\n${data.error}`);
            }
          } catch (error) {
            alert(`Error: ${error.message}`);
          } finally {
            nodeTestButton.disabled = false;
            nodeTestButton.textContent = 'Test Flag Evaluation';
          }
        });
      }
      
      // Python Test Evaluation button
      const pythonTestButton = document.getElementById('python-test-evaluation');
      if (pythonTestButton) {
        pythonTestButton.addEventListener('click', async () => {
          pythonTestButton.disabled = true;
          pythonTestButton.textContent = 'Testing...';
          
          try {
            const response = await fetch('http://localhost:5000/api/flag');
            const data = await response.json();
            
            let contextDetails = `Type: ${data.context?.kind || 'anonymous'}\n`;
            contextDetails += `Key: ${data.context?.key || 'unknown'}\n`;
            if (data.context?.name) contextDetails += `Name: ${data.context.name}\n`;
            if (data.context?.email) contextDetails += `Email: ${data.context.email}\n`;
            if (data.context?.location) contextDetails += `Location: ${data.context.location}\n`;
            
            let hashDetails = '';
            if (data.hashInfo) {
              hashDetails = `\n\nHash Info:\n`;
              hashDetails += `Hash Value: ${data.hashInfo.hashValue}\n`;
              hashDetails += `Bucket Value: ${data.hashInfo.bucketValue}\n`;
              hashDetails += `Salt: ${data.hashInfo.salt}`;
            }
            
            alert(`Test Evaluation Complete!\n\nFlag Value: ${data.value}\n\nContext:\n${contextDetails}${hashDetails}\n\nCheck the python-app-dev logs for detailed output.`);
          } catch (error) {
            alert(`Error testing flag evaluation: ${error.message}`);
          } finally {
            pythonTestButton.disabled = false;
            pythonTestButton.textContent = 'Test Flag Evaluation';
          }
        });
      }
      
      // Set up modal interaction handlers
      const modal = document.getElementById('context-modal');
      const modalOverlay = modal ? modal.querySelector('.modal-overlay') : null;
      const modalCancel = document.getElementById('modal-cancel');
      const modalSave = document.getElementById('modal-save');
      
      // Close modal when clicking overlay
      if (modalOverlay) {
        modalOverlay.addEventListener('click', () => {
          modal.classList.remove('show');
        });
      }
      
      // Close modal when clicking cancel button
      if (modalCancel) {
        modalCancel.addEventListener('click', () => {
          modal.classList.remove('show');
        });
      }
      
      // Save context when clicking save button
      if (modalSave) {
        modalSave.addEventListener('click', async () => {
          console.log('Save button clicked');
          
          // Determine which service panel opened the modal
          const serviceId = modal.dataset.serviceId;
          console.log('Service ID from modal:', serviceId);
          
          const servicePanel = serviceId === 'node' ? nodePanel : 
                               serviceId === 'php' ? phpPanel : 
                               serviceId === 'python' ? pythonPanel : null;
          console.log('Service panel:', servicePanel);
          
          if (servicePanel && servicePanel.contextModal) {
            console.log('Calling contextModal.save()');
            await servicePanel.contextModal.save();
          } else {
            console.error('Service panel or contextModal not found', {
              serviceId: serviceId,
              servicePanel: !!servicePanel,
              contextModal: servicePanel ? !!servicePanel.contextModal : false
            });
          }
        });
      }
      
      // Close modal on Escape key
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          if (modal.classList.contains('show')) {
            modal.classList.remove('show');
          }
          const relayStatusModal = document.getElementById('relay-status-modal');
          if (relayStatusModal && relayStatusModal.classList.contains('show')) {
            relayStatusModal.classList.remove('show');
          }
          const loadTestModal = document.getElementById('load-test-modal');
          if (loadTestModal && loadTestModal.classList.contains('show')) {
            loadTestModal.classList.remove('show');
          }
        }
      });
      
      // Clean up SSE connections when page unloads
      window.addEventListener('beforeunload', () => {
        console.log('Page unloading - cleaning up SSE connections');
        
        // Stop service panels
        if (nodePanel) {
          nodePanel.stopStatusPolling();
          if (nodePanel.eventSource) {
            nodePanel.eventSource.close();
          }
        }
        if (phpPanel) {
          phpPanel.stopStatusPolling();
          if (phpPanel.eventSource) {
            phpPanel.eventSource.close();
          }
        }
        
        // Stop log consoles
        if (appDevConsole) appDevConsole.stop();
        if (phpAppDevConsole) phpAppDevConsole.stop();
        if (relayProxyConsole) relayProxyConsole.stop();
        if (redisMonitorConsole) redisMonitorConsole.stop();
      });
      
      // Set up relay proxy status modal handlers
      const relayStatusButton = document.getElementById('relay-status-button');
      const relayStatusModal = document.getElementById('relay-status-modal');
      const relayStatusClose = document.getElementById('relay-status-close');
      const relayStatusOverlay = relayStatusModal ? relayStatusModal.querySelector('.modal-overlay') : null;
      
      // Helper function to escape HTML (prevent XSS)
      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }
      
      // Helper function to format Unix timestamp
      function formatTimestamp(unixMs) {
        if (!unixMs) return 'N/A';
        const date = new Date(unixMs);
        return date.toLocaleString();
      }
      
      // Helper function to format time ago
      function formatTimeAgo(unixMs) {
        if (!unixMs) return 'N/A';
        const now = Date.now();
        const diff = now - unixMs;
        const seconds = Math.floor(diff / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);
        const days = Math.floor(hours / 24);
        
        if (days > 0) return `${days}d ${hours % 24}h ago`;
        if (hours > 0) return `${hours}h ${minutes % 60}m ago`;
        if (minutes > 0) return `${minutes}m ${seconds % 60}s ago`;
        return `${seconds}s ago`;
      }
      
      if (relayStatusButton) {
        relayStatusButton.addEventListener('click', async () => {
          if (relayStatusModal) {
            relayStatusModal.classList.add('show');
            
            // Fetch relay proxy status
            const statusContent = document.getElementById('relay-status-content');
            if (statusContent) {
              statusContent.innerHTML = '<p>Loading status...</p>';
              
              try {
                const response = await fetch('http://localhost:4000/api/relay-status');
                
                if (!response.ok) {
                  throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Build comprehensive status display
                let html = '<div style="font-size: 13px; max-height: 600px; overflow-y: auto;">';
                
                // Show Redis warning if unavailable
                if (data.redisAvailable === false) {
                  html += '<div style="margin-bottom: 20px; padding: 15px; background-color: #fff3cd; border-left: 4px solid #ffc107; border-radius: 6px;">';
                  html += '<h4 style="margin: 0 0 10px 0; font-size: 16px; color: #856404;">âš ï¸ Redis Unavailable</h4>';
                  html += '<p style="margin: 0; color: #856404; font-size: 14px;">The Redis data store is not responding. The Relay Proxy is showing cached status information. Data store operations may be degraded or unavailable.</p>';
                  html += '</div>';
                }
                
                // Overall Status Section
                html += '<div style="margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 6px;">';
                html += '<h4 style="margin: 0 0 12px 0; font-size: 16px; color: #333;">Overall Status</h4>';
                
                const overallStatus = data.status || 'unknown';
                const statusColor = overallStatus === 'healthy' ? '#4caf50' : overallStatus === 'degraded' ? '#ff9800' : '#f44336';
                html += `<div style="margin-bottom: 8px;"><strong>Health:</strong> <span style="color: ${statusColor}; font-weight: 600; text-transform: uppercase;">${escapeHtml(overallStatus)}</span></div>`;
                
                if (data.version) {
                  html += `<div style="margin-bottom: 8px;"><strong>Relay Version:</strong> ${escapeHtml(data.version)}</div>`;
                }
                if (data.clientVersion) {
                  html += `<div style="margin-bottom: 8px;"><strong>SDK Version:</strong> ${escapeHtml(data.clientVersion)}</div>`;
                }
                if (data.environments) {
                  html += `<div><strong>Environments:</strong> ${Object.keys(data.environments).length}</div>`;
                }
                html += '</div>';
                
                // Per-Environment Details
                if (data.environments) {
                  const envNames = Object.keys(data.environments);
                  
                  envNames.forEach((envName, index) => {
                    const env = data.environments[envName];
                    
                    html += '<div style="margin-bottom: 20px; padding: 15px; background-color: #ffffff; border: 1px solid #e0e0e0; border-radius: 6px;">';
                    html += `<h4 style="margin: 0 0 12px 0; font-size: 15px; color: #405BFF;">Environment ${index + 1}: ${escapeHtml(envName)}</h4>`;
                    
                    // Basic Info
                    html += '<div style="margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #f0f0f0;">';
                    if (env.envId) {
                      html += `<div style="margin-bottom: 6px; font-size: 12px;"><strong>Environment ID:</strong> <code style="background-color: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 11px;">${escapeHtml(env.envId)}</code></div>`;
                    }
                    if (env.sdkKey) {
                      html += `<div style="margin-bottom: 6px; font-size: 12px;"><strong>SDK Key:</strong> <code style="background-color: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 11px;">${escapeHtml(env.sdkKey)}</code></div>`;
                    }
                    if (env.mobileKey) {
                      html += `<div style="font-size: 12px;"><strong>Mobile Key:</strong> <code style="background-color: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 11px;">${escapeHtml(env.mobileKey)}</code></div>`;
                    }
                    html += '</div>';
                    
                    // Connection Status
                    if (env.status || env.connectionStatus) {
                      html += '<div style="margin-bottom: 12px;">';
                      html += '<div style="font-weight: 600; margin-bottom: 8px; color: #555;">ðŸ”Œ Connection Status</div>';
                      
                      if (env.status) {
                        const connColor = env.status === 'connected' ? '#4caf50' : '#f44336';
                        html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>Status:</strong> <span style="color: ${connColor}; font-weight: 600;">${escapeHtml(env.status).toUpperCase()}</span></div>`;
                      }
                      
                      if (env.connectionStatus) {
                        const cs = env.connectionStatus;
                        const stateColor = cs.state === 'VALID' ? '#4caf50' : cs.state === 'INTERRUPTED' ? '#ff9800' : cs.state === 'INITIALIZING' ? '#2196f3' : '#f44336';
                        html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>State:</strong> <span style="color: ${stateColor}; font-weight: 600;">${escapeHtml(cs.state)}</span></div>`;
                        
                        if (cs.stateSince) {
                          html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>State Since:</strong> ${formatTimeAgo(cs.stateSince)} <span style="color: #999; font-size: 11px;">(${formatTimestamp(cs.stateSince)})</span></div>`;
                        }
                        
                        if (cs.lastError) {
                          html += '<div style="margin: 8px 0 0 12px; padding: 8px; background-color: #fff3cd; border-left: 3px solid #ffc107; border-radius: 3px;">';
                          html += `<div style="font-weight: 600; color: #856404; margin-bottom: 4px;">âš ï¸ Last Error</div>`;
                          if (cs.lastError.kind) {
                            html += `<div style="font-size: 12px; color: #856404;"><strong>Type:</strong> ${escapeHtml(cs.lastError.kind)}</div>`;
                          }
                          if (cs.lastError.time) {
                            html += `<div style="font-size: 12px; color: #856404;"><strong>Time:</strong> ${formatTimestamp(cs.lastError.time)}</div>`;
                          }
                          html += '</div>';
                        }
                      }
                      html += '</div>';
                    }
                    
                    // Data Store Status
                    if (env.dataStoreStatus) {
                      const ds = env.dataStoreStatus;
                      html += '<div style="margin-bottom: 12px;">';
                      html += '<div style="font-weight: 600; margin-bottom: 8px; color: #555;">ðŸ’¾ Data Store Status</div>';
                      
                      const dsStateColor = ds.state === 'VALID' ? '#4caf50' : ds.state === 'INTERRUPTED' ? '#ff9800' : '#f44336';
                      html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>State:</strong> <span style="color: ${dsStateColor}; font-weight: 600;">${escapeHtml(ds.state)}</span></div>`;
                      
                      if (ds.state === 'INTERRUPTED' && ds.error) {
                        html += '<div style="margin: 8px 0 8px 12px; padding: 8px; background-color: #fff3cd; border-left: 3px solid #ffc107; border-radius: 3px;">';
                        html += `<div style="font-weight: 600; color: #856404; margin-bottom: 4px;">âš ï¸ Error</div>`;
                        html += `<div style="font-size: 12px; color: #856404;">${escapeHtml(ds.error)}</div>`;
                        html += '</div>';
                      }
                      
                      if (ds.stateSince) {
                        html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>State Since:</strong> ${formatTimeAgo(ds.stateSince)} <span style="color: #999; font-size: 11px;">(${formatTimestamp(ds.stateSince)})</span></div>`;
                      }
                      
                      if (ds.database) {
                        html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>Database:</strong> ${escapeHtml(ds.database).toUpperCase()}</div>`;
                      }
                      
                      if (ds.dbServer) {
                        html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>Server:</strong> <code style="background-color: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 11px;">${escapeHtml(ds.dbServer)}</code></div>`;
                      }
                      
                      if (ds.dbPrefix) {
                        html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>Key Prefix:</strong> <code style="background-color: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 11px;">${escapeHtml(ds.dbPrefix)}</code></div>`;
                      }
                      
                      if (ds.dbTable) {
                        html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>Table:</strong> <code style="background-color: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 11px;">${escapeHtml(ds.dbTable)}</code></div>`;
                      }
                      
                      html += '</div>';
                    }
                    
                    // Big Segments Status
                    if (env.bigSegmentStatus) {
                      const bs = env.bigSegmentStatus;
                      html += '<div style="margin-bottom: 12px;">';
                      html += '<div style="font-weight: 600; margin-bottom: 8px; color: #555;">ðŸ“Š Big Segments Status</div>';
                      
                      if (bs.available !== undefined) {
                        const availColor = bs.available ? '#4caf50' : '#f44336';
                        html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>Available:</strong> <span style="color: ${availColor}; font-weight: 600;">${bs.available ? 'YES' : 'NO'}</span></div>`;
                      }
                      
                      if (bs.potentiallyStale !== undefined) {
                        const staleColor = bs.potentiallyStale ? '#ff9800' : '#4caf50';
                        html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>Potentially Stale:</strong> <span style="color: ${staleColor}; font-weight: 600;">${bs.potentiallyStale ? 'YES' : 'NO'}</span></div>`;
                      }
                      
                      if (bs.lastSynchronizedOn) {
                        html += `<div style="margin-bottom: 6px; margin-left: 12px;"><strong>Last Sync:</strong> ${formatTimeAgo(bs.lastSynchronizedOn)} <span style="color: #999; font-size: 11px;">(${formatTimestamp(bs.lastSynchronizedOn)})</span></div>`;
                      }
                      
                      html += '</div>';
                    }
                    
                    html += '</div>';
                  });
                }
                
                html += '</div>';
                statusContent.innerHTML = html;
                
              } catch (error) {
                // Disconnected state - show error and troubleshooting
                let html = '<div style="font-size: 14px;">';
                html += `<p><strong>Status:</strong> <span style="color: #f44336;">Disconnected</span></p>`;
                html += `<p><strong>Error:</strong> ${escapeHtml(error.message)}</p>`;
                
                html += '<div style="margin-top: 20px; padding: 15px; background-color: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">';
                html += '<p style="margin: 0 0 10px 0; font-weight: 600; color: #856404;">Troubleshooting Steps:</p>';
                html += '<ol style="margin: 0; padding-left: 20px; color: #856404;">';
                html += '<li style="margin-bottom: 8px;">Check if the relay proxy container is running: <code style="background-color: #f5f5f5; padding: 2px 6px; border-radius: 3px;">docker ps | grep relay-proxy</code></li>';
                html += '<li style="margin-bottom: 8px;">Verify the relay proxy is accessible: <code style="background-color: #f5f5f5; padding: 2px 6px; border-radius: 3px;">curl http://localhost:8030/status</code></li>';
                html += '<li style="margin-bottom: 8px;">Check relay proxy logs in the dashboard below</li>';
                html += '<li>Ensure the relay proxy is configured with a valid SDK key</li>';
                html += '</ol>';
                html += '</div>';
                
                html += '</div>';
                statusContent.innerHTML = html;
              }
            }
          }
        });
      }
      
      if (relayStatusClose) {
        relayStatusClose.addEventListener('click', () => {
          if (relayStatusModal) {
            relayStatusModal.classList.remove('show');
          }
        });
      }
      
      if (relayStatusOverlay) {
        relayStatusOverlay.addEventListener('click', () => {
          if (relayStatusModal) {
            relayStatusModal.classList.remove('show');
          }
        });
      }
      
      // Set up load test modal handlers
      const loadTestButton = document.getElementById('load-test-button');
      const loadTestModal = document.getElementById('load-test-modal');
      const loadTestClose = document.getElementById('load-test-close');
      const loadTestStart = document.getElementById('load-test-start');
      const loadTestOverlay = loadTestModal ? loadTestModal.querySelector('.modal-overlay') : null;
      
      if (loadTestButton) {
        loadTestButton.addEventListener('click', () => {
          if (loadTestModal) {
            loadTestModal.classList.add('show');
            // Clear previous output
            const output = document.getElementById('load-test-output');
            if (output) {
              output.style.display = 'none';
              output.innerHTML = '';
            }
          }
        });
      }
      
      if (loadTestClose) {
        loadTestClose.addEventListener('click', () => {
          if (loadTestModal) {
            loadTestModal.classList.remove('show');
          }
        });
      }
      
      if (loadTestOverlay) {
        loadTestOverlay.addEventListener('click', () => {
          if (loadTestModal) {
            loadTestModal.classList.remove('show');
          }
        });
      }
      
      if (loadTestStart) {
        loadTestStart.addEventListener('click', async () => {
          const requestsInput = document.getElementById('load-test-requests');
          const concurrencyInput = document.getElementById('load-test-concurrency');
          const serviceRadio = document.querySelector('input[name="load-test-service"]:checked');
          const output = document.getElementById('load-test-output');
          
          if (!requestsInput || !concurrencyInput || !serviceRadio || !output) {
            return;
          }
          
          const requests = parseInt(requestsInput.value) || 100;
          const concurrency = parseInt(concurrencyInput.value) || 10;
          const service = serviceRadio.value;
          
          // Show output area
          output.style.display = 'block';
          output.innerHTML = '<p>Starting load test...</p>';
          
          try {
            const response = await fetch('http://localhost:4000/api/load-test', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ requests, concurrency, service })
            });
            
            const data = await response.json();
            
            // Display results
            let html = '<div style="line-height: 1.6;">';
            html += `<p><strong>Load Test Results</strong></p>`;
            html += `<p>Total Requests: ${data.totalRequests || requests}</p>`;
            html += `<p>Successful: ${data.successful || 0}</p>`;
            html += `<p>Failed: ${data.failed || 0}</p>`;
            html += `<p>Average Response Time: ${data.avgResponseTime || 'N/A'}ms</p>`;
            html += `<p>Requests/sec: ${data.requestsPerSecond || 'N/A'}</p>`;
            html += '</div>';
            
            output.innerHTML = html;
          } catch (error) {
            output.innerHTML = '<p style="color: #f44336;">Error running load test</p>';
          }
        });
      }
    });
  </script>
</body>
</html>
